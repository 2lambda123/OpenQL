/**
 * @file    codegen_cc.cc
 * @date    201810xx
 * @author  Wouter Vlothuizen (wouter.vlothuizen@tno.nl)
 * @brief   code generator backend for the Central Controller
 * @note    here we don't check whether the sequence of calling code generator
 *          functions is correct
 */

#include "codegen_cc.h"
#include "eqasm_backend_cc.h"

#include <version.h>
#include <options.h>

// constants
#define IMPLICIT_COP  -1          // implicit classic operand


namespace ql {


#if OPT_FEEDBACK
// FIXME: preliminary support based on '20200929_openql_feedback_design.docx'

// temporary definitions for condition type that will be added to class gate
enum {
    // 0 operands:
    cond_always,
    // 1 operand:
    cond, cond_not,
    // 2 operands
    cond_and, cond_nand, cond_or, cond_nor, cond_xor, cond_xnor
};

typedef std::vector<int> tBitVars;

#endif

/************************************************************************\
| Generic
\************************************************************************/

void codegen_cc::init(const quantum_platform &platform)
{
    // NB: a new eqasm_backend_cc is instantiated per call to compile, and
    // as a result also a codegen_cc, so we don't need to cleanup
    this->platform = &platform;
    settings.loadBackendSettings(platform);

    // optionally preload codewordTable
    std::string map_input_file = options::get("backend_cc_map_input_file");
    if(!map_input_file.empty()) {
        DOUT("loading map_input_file='" << map_input_file << "'");
        json map = load_json(map_input_file);
        codewordTable = map["codeword_table"];      // FIXME: use json_get
        mapPreloaded = true;
    }


#if OPT_FEEDBACK   // FIXME: WIP on feedback: allocate SM bits
    // iterate over instruments
    for(size_t instrIdx=0; instrIdx<settings.getInstrumentsSize(); instrIdx++) {
        const settings_cc::tInstrumentControl ic = settings.getInstrumentControl(instrIdx);
        if(JSON_EXISTS(ic.controlMode, "result_bits")) {  // this instrument mode produces results (i.e. it is a measurement device)
            // FIXME: maintain mapping instrument -> SM
            IOUT("instrument '" << ic.ii.instrumentName << "' (index " << instrIdx << ") is used for feedback");
        }
    }
#endif
}

std::string codegen_cc::getProgram()
{
#if OPT_FEEDBACK
	return codeSection.str() + datapathSection.str();
#else
    return codeSection.str();
#endif
}

std::string codegen_cc::getMap()
{
    json map;

    map["note"] = "generated by OpenQL CC backend version " CC_BACKEND_VERSION_STRING;
    map["codeword_table"] = codewordTable;
    return SS2S(std::setw(4) << map << std::endl);
}


/************************************************************************\
| 'Program' level functions
\************************************************************************/

void codegen_cc::programStart(const std::string &progName)
{
    // emit program header
    codeSection << std::left;    // assumed by emit()
    codeSection << "# Program: '" << progName << "'" << std::endl;   // NB: put on top so it shows up in internal CC logging
    codeSection << "# CC_BACKEND_VERSION " << CC_BACKEND_VERSION_STRING << std::endl;
    codeSection << "# OPENQL_VERSION " << OPENQL_VERSION_STRING << std::endl;
    codeSection << "# Note:    generated by OpenQL Central Controller backend" << std::endl;
    codeSection << "#" << std::endl;
    emitProgramStart();

    datapathSection << std::left;    // assumed by emitDp()
	emitDp(".DATAPATH", "");

    vcd.programStart(platform->qubit_number, platform->cycle_time, MAX_GROUPS, settings);
}


void codegen_cc::programFinish(const std::string &progName)
{
#if OPT_RUN_ONCE   // program runs once only
    emit("", "stop");
#else   // CC-light emulation: loop indefinitely
    emit("",      // no CCIO selector
         "jmp",
         "@mainLoop",
         "# loop indefinitely");
#endif
#if OPT_FEEDBACK
    emit(".END");   // end .CODE section

	emitDp(".END", "");
#endif

    vcd.programFinish(progName);
}

/************************************************************************\
| 'Kernel' level functions
\************************************************************************/

void codegen_cc::kernelStart()
{
    utils::zero(lastEndCycle);       // FIXME: actually, bundle.startCycle starts counting at 1
}

void codegen_cc::kernelFinish(const std::string &kernelName, size_t durationInCycles)
{
    vcd.kernelFinish(kernelName, durationInCycles);
}

/************************************************************************\
| 'Bundle' level functions
\************************************************************************/

/*
    Our strategy is to first process all customGate's in a bundle, storing the
    relevant information in bundleInfo. Then, when all work for a bundle has
    been collected, we generate code in bundleFinish

    - bundleStart():
    clear bundleInfo, which maintains the work that needs to be performed for bundle

    - customGate():
    collect gate information in bundleInfo

    - bundleFinish():
    generate code for bundle from information collected in bundleInfo (which
    may be empty if no custom gates are present in bundle)
*/

// bundleStart: see 'strategy' above
void codegen_cc::bundleStart(const std::string &cmnt)
{
    // create 'matrix' of tBundleInfo with proper vector size per instrument
	bundleInfo.clear();
    tBundleInfo empty = {"", 0, settings_cc::NO_STATIC_CODEWORD_OVERRIDE, -1, -1};	// FIXME: create proper constructor
    for(size_t instrIdx=0; instrIdx<settings.getInstrumentsSize(); instrIdx++) {
        const settings_cc::tInstrumentControl ic = settings.getInstrumentControl(instrIdx);
        bundleInfo.emplace_back(ic.controlModeGroupCnt,   	// one tBundleInfo per group in the control mode selected for instrument
								empty);  					// empty tBundleInfo
    }

    comment(cmnt);
    datapathSection << cmnt << std::endl;	// FIXME: comment is not full appropriate, but at least allows matching with .CODE section
}


// FIXME: helper, relocate
int allocateSmBit(size_t cop, size_t instrIdx)
{
	static int smBit = 0;

	smBit++;	// FIXME

	return smBit;
}


static int getSizeTag(int numReadouts) {
	int sizeTag;

	if(numReadouts == 0) {
		FATAL("inconsistency in number of readouts");
	} else if(numReadouts <= 8) {
		sizeTag = 0;			// 0=byte
	} else if(numReadouts <= 16) {
		sizeTag = 1;
	} else if(numReadouts <= 32) {	// NB: should currently not occur since we have a maximum of 16 inputs on UHF
		sizeTag = 2;
	} else {
		FATAL("inconsistency detected: too many readouts");
	}
	return sizeTag;
}


// Static helper function for bundleFinish()
typedef struct {
	uint32_t groupDigOut;   // codeword/mask fragment for this group
	std::string comment;    // comment for instruction stream
} tCalcGroupDigOut;

static tCalcGroupDigOut calcGroupDigOut(size_t instrIdx, size_t group, size_t nrGroups, const settings_cc::tInstrumentControl &ic, int staticCodewordOverride)
{
	tCalcGroupDigOut ret{0, ""};

	// determine control mode group FIXME: more explanation
	int controlModeGroup = -1;
	if(ic.controlModeGroupCnt == 0) {
		JSON_FATAL("'control_bits' not defined or empty in 'control_modes/" << ic.refControlMode <<"'");
#if OPT_VECTOR_MODE
		} else if(ic.controlModeGroupCnt == 1) {                    // vector mode: group addresses channel within vector
	controlModeGroup = 0;
#endif
	} else if(group < ic.controlModeGroupCnt) {                 // normal mode: group selects control group
		controlModeGroup = group;
	} else {
		// FIXME: will become logic error once we get nrGroups right
		JSON_FATAL("instrument '" << ic.ii.instrumentName
								  << "' uses " << nrGroups
								  << " groups, but control mode '" << ic.refControlMode
								  << "' only defines " << ic.controlModeGroupCnt
								  << " groups in 'control_bits'");
	}

	// get number of control bits for group
	const json &groupControlBits = ic.controlMode["control_bits"][controlModeGroup];    // NB: tests above guarantee existence
	DOUT("instrumentName=" << ic.ii.instrumentName
						   << ", slot=" << ic.ii.slot
						   << ", control mode group=" << controlModeGroup
						   << ", group control bits: " << groupControlBits);
	size_t nrGroupControlBits = groupControlBits.size();


	// calculate digital output for group
	if(nrGroupControlBits == 1) {       // single bit, implying this is a mask (not code word)
		ret.groupDigOut |= 1<<(int)groupControlBits[0];     // NB: we assume the mask is active high, which is correct for VSM and UHF-QC
		// FIXME: check controlModeGroup vs group
	} else if(nrGroupControlBits > 1) {                 // > 1 bit, implying code word
#if OPT_VECTOR_MODE
		//  allow single code word for vector of groups. FIXME: requires looking at all sd.signal before assigning code word
	if(group != controlModeGroup) {
		// FIXME: unfinished work on vector mode
	}
#endif

		// find or assign code word
		uint32_t codeword = 0;
		bool codewordOverriden = false;
#if OPT_SUPPORT_STATIC_CODEWORDS
		codeword = staticCodewordOverride;
		codewordOverriden = true;
#else
		codeword = assignCodeword(ic.ii.instrumentName, instrIdx, group);
#endif

		// convert codeword to digOut
		for(size_t idx=0; idx<nrGroupControlBits; idx++) {
			int codeWordBit = nrGroupControlBits-1-idx;    // NB: groupControlBits defines MSB..LSB
			if(codeword & (1<<codeWordBit)) ret.groupDigOut |= 1<<(int)groupControlBits[idx];
		}

		ret.comment = SS2S("  # slot=" << ic.ii.slot
									   << ", instrument='" << ic.ii.instrumentName << "'"
									   << ", group=" << group
									   << ": codeword=" << codeword
									   << std::string(codewordOverriden ? " (static override)" : "")
									   << ": groupDigOut=0x" << std::hex << std::setfill('0') << std::setw(8) << ret.groupDigOut
		);
	} else {    // nrGroupControlBits < 1
		JSON_FATAL("key 'control_bits' empty for group " <<
														 controlModeGroup << " on instrument '" <<
														 ic.ii.instrumentName << "'");
	}

	// add trigger to digOut
	size_t nrTriggerBits = ic.controlMode["trigger_bits"].size();
	if(nrTriggerBits == 0) {                                    // no trigger
		// do nothing
	} else if(nrTriggerBits == 1) {                             // single trigger for all groups (NB: will possibly assigned multiple times)
		ret.groupDigOut |= 1 << (int)ic.controlMode["trigger_bits"][0];
#if 1   // FIXME: trigger per group, nrGroups always 32
	} else if(nrTriggerBits == nrGroups) {                      // trigger per group
		ret.groupDigOut |= 1 << (int)ic.controlMode["trigger_bits"][group];
#endif
	} else {
		JSON_FATAL("instrument '" << ic.ii.instrumentName
								  << "' uses " << nrGroups
								  << " groups, but control mode '" << ic.refControlMode
								  << "' defines " << nrTriggerBits
								  << " trigger bits in 'trigger_bits' (must be 1 or #groups)");
// FIXME: 20200924 error shows 32: "E       TypeError: Error : instrument 'mw_0' uses 32 groups, but control mode 'awg8-mw-direct-iq' defines 2 trigger bits in 'trigger_bits' (must be 1 or #groups)"
	} // FIXME: e.g. HDAWG does not support > 1 trigger bit. dual-QWG required 2 trigger bits

	return ret;
}


// bundleFinish: see 'strategy' above
// FIXME: split into smaller parts
void codegen_cc::bundleFinish(size_t startCycle, size_t durationInCycles, bool isLastBundle)
{
	bool bundleHasReadout = false;

    // iterate over instruments
    for(size_t instrIdx=0; instrIdx<settings.getInstrumentsSize(); instrIdx++) {
    	// get control info from instrument settings
        const settings_cc::tInstrumentControl ic = settings.getInstrumentControl(instrIdx);
        if(ic.ii.slot >= MAX_SLOTS) {
            JSON_FATAL("illegal slot " << ic.ii.slot <<
                       " on instrument '" << ic.ii.instrumentName);
        }

		/************************************************************************\
		| collect code generation info from all groups within one instrument
		\************************************************************************/

        // FIXME: the term 'group' is used in a diffused way: 1) index of signal vectors, 2) controlModeGroup
        bool instrHasOutput = false;
        uint32_t digOut = 0;                                                // the digital output value sent over the instrument interface
        int maxDurationInCycles = 0;                                   		// maximum duration over groups that are used, one instrument
#if OPT_FEEDBACK
		bool instrHasReadout = false;
		typedef struct {
			int smBit;
			int bit;
			int cop;	// classic operand as annotation
			int qubit;	// annotation
		} tReadoutInfo;
		std::map<int, tReadoutInfo> readoutMap;								// NB: key is instrIdx
#endif

		// iterate over groups of instrument
        size_t nrGroups = bundleInfo[instrIdx].size();
        for(size_t group=0; group<nrGroups; group++) {
            tBundleInfo *bi = &bundleInfo[instrIdx][group];                 // shorthand

            // handle output
            if(!bi->signalValue.empty()) {                                  // signal defined, i.e.: we need to output something
                // compute maximum duration over all groups
                if(bi->durationInCycles > maxDurationInCycles) maxDurationInCycles = bi->durationInCycles;

                tCalcGroupDigOut gdo = calcGroupDigOut(instrIdx, group, nrGroups, ic, bi->staticCodewordOverride);
                digOut |= gdo.groupDigOut;
                comment(gdo.comment);

                vcd.bundleFinishGroup(startCycle, bi->durationInCycles, gdo.groupDigOut, bi->signalValue, instrIdx, group);

                instrHasOutput = true;
            } // if(signal defined)

#if OPT_FEEDBACK
            // handle readout (i.e. when necessary, create readoutMap entry, and set flags bundleHasReadout and instrHasReadout)
            // NB: we allow for instruments that perform the input side of readout only, without signal generation by the
            // same instrument, which might be needed in the future
            // FIXME: also generate VCD

			if(bi->readoutQubit >= 0) { // readout requested
				// FIXME: test similar to settings_cc::getInstrumentControl, move
				// check existence of key 'result_bits'
				if (!JSON_EXISTS(ic.controlMode, "result_bits")) {    // this instrument mode produces results (i.e. it is a measurement device)
					JSON_FATAL("readout requested on instrument '" << ic.ii.instrumentName << "', but key '" << ic.refControlMode << "/result_bits is not present");
				}

				// check existence of key 'result_bits[group]'
				const json &groupResultBits = ic.controlMode["result_bits"][group];
				size_t nrGroupResultBits = groupResultBits.size();
				if (nrGroupResultBits != 1) {                     // single bit (NB: per group)
					JSON_FATAL("key '" << ic.refControlMode << "/result_bits[" << group << "] must have 1 bit instead of " << nrGroupResultBits);
				}

#if 1	// FIXME: redundant, inherent in bi??
				// get our qubit
				const json qubits = json_get<const json>(*ic.ii.instrument, "qubits", ic.ii.instrumentName);   // NB: json_get<const json&> unavailable
				size_t qubitGroupCnt = qubits.size();                                  // NB: JSON key qubits is a 'matrix' of [groups*qubits]
				if (group >= qubitGroupCnt) {
					FATAL("group " << group << " not defined in '" << ic.ii.instrumentName << "/qubits'");
				}
				const json qubitsOfGroup = qubits[group];
				if (qubitsOfGroup.size() != 1) {
					FATAL("group " << group << " of '" << ic.ii.instrumentName << "/qubits' should define 1 qubit, not " << qubitsOfGroup.size());
				}
				int qubit = qubitsOfGroup[0];
#endif

				if (bi->readoutQubit == qubit) {          	// this instrument group handles requested qubit
					bundleHasReadout = true;
					instrHasReadout = true;

					int bit = (int) groupResultBits[0];        	// bit on digital interface. NB: we assume the result is active high, which is correct for UHF-QC

					// get classic operand
					if (bi->readoutCop >= 0) {
						WOUT("ignoring explicit assignment to classic operand" << bi->readoutCop << "for measurement of qubit" << bi->readoutQubit);
					}
					int cop = qubit;                        // implicit cop for qubit

					// allocate SM bit for cop
					int smBit = allocateSmBit(cop, instrIdx);

					// remind mapping of bit -> smBit for setting MUX
					readoutMap.emplace(group, tReadoutInfo{smBit, bit, cop, qubit});
				} else {
					FATAL("inconsistency FIXME");
				};
			}
#endif
        } // for(group)


		/************************************************************************\
		| turn code generation info collected above into actual code
		\************************************************************************/

		if(isLastBundle) {
			comment(SS2S(" # last bundle of kernel, will pad outputs to match durations"));
		}

#if OPT_FEEDBACK
		// FIXME: terrible hack
		if(instrHasReadout) {	// FIXME: also allow runtime selection by option
			// shorten output to preserve timeline while injecting time for feedback below
			int smWait = settings.getSmWait();
			maxDurationInCycles -= 1+smWait;	// adjust gate duration (Ugh)
			if(maxDurationInCycles <= 1) {
				FATAL("maxDurationInCycles adjusted to " << maxDurationInCycles);
			}
		}
#endif

        // generate code for instrument output
        if(instrHasOutput) {
            comment(SS2S("  # slot=" << ic.ii.slot
                    << ", instrument='" << ic.ii.instrumentName << "'"
                    << ": lastEndCycle=" << lastEndCycle[instrIdx]
                    << ", startCycle=" << startCycle
                    << ", maxDurationInCycles=" << maxDurationInCycles
                    ));

            padToCycle(lastEndCycle[instrIdx], startCycle, ic.ii.slot, ic.ii.instrumentName);

            // emit code for slot output
            emit(SS2S("[" << ic.ii.slot << "]").c_str(),      // CCIO selector
                 "seq_out",
                 SS2S("0x" << std::hex << std::setfill('0') << std::setw(8) << digOut << std::dec <<
                      "," << maxDurationInCycles),
                 SS2S("# cycle " << startCycle << "-" << startCycle+maxDurationInCycles << ": code word/mask on '" << ic.ii.instrumentName+"'").c_str());

            // update lastEndCycle
            lastEndCycle[instrIdx] = startCycle + maxDurationInCycles;

        } else {    // !isInstrUsed
            // nothing to do, we delay emitting till a slot is used or kernel finishes (i.e. isLastBundle just below)
        }


#if OPT_FEEDBACK
        // FIXME: move to emitReadout()
		// generate code for instrument input of readout results
		if(bundleHasReadout) {	// FIXME: also allow runtime selection by option
			if(startCycle > lastEndCycle[instrIdx]) {	// i.e. if(!instrHasOutput)
				padToCycle(lastEndCycle[instrIdx], startCycle, ic.ii.slot, ic.ii.instrumentName);
			}

			// code generation for participating and non-participating instruments (NB: must take equal number of sequencer cycles)
			if(instrHasReadout) {
				// FIXME:
				int smAddr = 0;
				int mux = 0;				// get/assign LUT

				// emit datapath code
				emitDp(SS2S("[" << ic.ii.slot << "]"), SS2S(".MUX " << mux));
				for(auto readout : readoutMap) {
					int group = readout.first;
					tReadoutInfo ri = readout.second;

					emitDp(SS2S("[" << ic.ii.slot << "]"),      	// CCIO selector
							SS2S("SM[" << ri.smBit << "] := I[" << ri.bit << "]"),
							SS2S("# cop " << ri.cop << " = readout(q" << ri.qubit << ")"));

					int mySmAddr = ri.smBit/8;
				}

				// emit code for slot input
				int sizeTag = getSizeTag(readoutMap.size());		// compute DSM transfer size tag (for 'seq_in_sm' instruction)
				emit(SS2S("[" << ic.ii.slot << "]").c_str(),      	// CCIO selector
					"seq_in_sm",
					SS2S("S" << smAddr << ","  << mux << "," << sizeTag),
					SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << lastEndCycle[instrIdx]+1 << ": readout on '" << ic.ii.instrumentName+"'").c_str());
				lastEndCycle[instrIdx]++;		// FIXME: this time has not been scheduled, but is interjected here at the backend level
			} else {
				// FIXME:
				int smAddr = 0;
				int smTotalSize = 6;	// FIXME: calculate, requires overview over all measurements of bundle, or take a safe max

				// emit code for non-participating instrument
				emit(SS2S("[" << ic.ii.slot << "]").c_str(),      	// CCIO selector
					"seq_inv_sm",
					SS2S("S" << smAddr << ","  << smTotalSize),
					SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << lastEndCycle[instrIdx]+1 << ": no readout on '" << ic.ii.instrumentName+"'").c_str());
				lastEndCycle[instrIdx]++;		// FIXME: this time has not been scheduled, but is interjected here at the backend level
			}

			// code generation common to paths above
			int smWait = settings.getSmWait();
			emit(SS2S("[" << ic.ii.slot << "]").c_str(),      		// CCIO selector
				"seq_wait",
				SS2S(smWait),
				SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << lastEndCycle[instrIdx]+smWait << ": wait for DSM data distribution on '" << ic.ii.instrumentName+"'").c_str());

			// update lastEndCycle
			lastEndCycle[instrIdx] += smWait;	// FIXME: this time has not been scheduled, but is interjected here at the backend level
		}
#endif

		// for last bundle, pad end of bundle to align durations
        if(isLastBundle) {
            padToCycle(lastEndCycle[instrIdx], startCycle+durationInCycles, ic.ii.slot, ic.ii.instrumentName);		// FIXME: use maxDurationInCycles and/or check consistency
        }

        vcd.bundleFinish(startCycle, digOut, maxDurationInCycles, instrIdx);
    } // for(instrIdx)

    comment("");    // blank line to separate bundles
}

/************************************************************************\
| Quantum instructions
\************************************************************************/

// customGate: single/two/N qubit gate, including readout, see 'strategy' above
// translates 'gate' representation to 'waveform' representation (tBundleInfo) and maps qubits to instruments & group.
// Does not deal with the control mode and digital interface of the instrument.

void codegen_cc::customGate(
        const std::string &iname,
        const std::vector<size_t> &qops,
        const std::vector<size_t> &cops,
        double angle, size_t startCycle, size_t durationInCycles)
{
#if 0   // FIXME: test for angle parameter
    if(angle != 0.0) {
        DOUT("iname=" << iname << ", angle=" << angle);
    }
#endif

    vcd.customGate(iname, qops, startCycle, durationInCycles);


    //  determine whether this is a readout instruction
    bool isReadout = settings.isReadout(iname);

    // generate comment (also performs some checks)
    if(isReadout) {
        if(cops.empty()) {
            /*  NB: existing code uses empty cops, i.e. no explicit classical register.
                On the one hand this historically seems to imply assignment to an
                implicit 'register' in the CC-light that can be used for conditional
                gates.
                On the other hand, measurement results can also be read from the
                readout device without the control device ever taking notice of the
                value
            */
            // FIXME: define meaning: no classical target, or implied target (classical register matching qubit)
            comment(SS2S(" # READOUT: " << iname << "(q" << qops[0] << ")"));
        } else if(cops.size() == 1) {
            comment(SS2S(" # READOUT: " << iname << "(c" << cops[0] << ",q" << qops[0] << ")"));
        } else {
            FATAL("Readout instruction requires 0 or 1 classical operands, not " << cops.size());   // FIXME: provide context
        }
    } else { // handle all other instruction types than "readout"
        // generate comment. NB: we don't have a particular limit for the number of operands
        std::stringstream cmnt;
        cmnt << " # gate '" << iname << " ";    // FIXME: make QASM compatible, use library function?
        for(size_t i=0; i<qops.size(); i++) {
            cmnt << qops[i];
            if(i<qops.size()-1) cmnt << ",";
        }
        cmnt << "'";
        comment(cmnt.str());
    }

    // find instruction (gate definition)
    const json &instruction = platform->find_instruction(iname);
    // find signal vector definition for instruction
    settings_cc::tSignalDef sd = settings.findSignalDefinition(instruction, iname);

    // iterate over signals defined for instruction (e.g. several operands or types, and thus instruments)
    for(size_t s=0; s<sd.signal.size(); s++) {
        tCalcSignalValue csv = calcSignalValue(sd, s, qops, iname);

        // store signal value, checking for conflicts
        tBundleInfo *bi = &bundleInfo[csv.si.instrIdx][csv.si.group];       // shorthand
        if(bi->signalValue.empty()) {                                       // signal not yet used
            bi->signalValue = csv.signalValueString;
#if OPT_SUPPORT_STATIC_CODEWORDS
            // FIXME: this does not only provide support, but findStaticCodewordOverride() currently actually requires static codewords
            bi->staticCodewordOverride = settings.findStaticCodewordOverride(instruction, csv.operandIdx, iname); // NB: function return -1 means 'no override'
#endif
        } else if(bi->signalValue == csv.signalValueString) {               // signal unchanged
            // do nothing
        } else {
            EOUT("Code so far:\n" << codeSection.str());                    // provide context to help finding reason. FIXME: not great
            FATAL("Signal conflict on instrument='" << csv.si.ic.ii.instrumentName <<
                  "', group=" << csv.si.group <<
                  ", between '" << bi->signalValue <<
                  "' and '" << csv.signalValueString << "'");               // FIXME: add offending instruction
        }

        // store signal duration
        bi->durationInCycles = durationInCycles;

#if OPT_FEEDBACK
        // FIXME: assumes that group configuration for readout matches that of output
		// store operands used for readout, actual work is postponed to bundleFinish()
        if(isReadout) {
            int cop = !cops.empty() ? cops[0] : IMPLICIT_COP;
            bi->readoutCop = cop;   // FIXME: naming, we do use cop, but rename qop to qubit below

            // store qubit
            if(qops.size() == 1) {
                bi->readoutQubit = qops[0];
            } else {
                FATAL("Readout instruction requires exactly 1 quantum operand, not " << qops.size());   // FIXME: provide context
            }
        }

        // store expression for conditional gates
        // FIXME: implement
#endif

        DOUT("customGate(): iname='" << iname <<
             "', duration=" << durationInCycles <<
             " [cycles], instrIdx=" << csv.si.instrIdx <<
             ", group=" << csv.si.group);

        // NB: code is generated in bundleFinish()
    }   // for(signal)
}

void codegen_cc::nopGate()
{
    comment("# NOP gate");
    FATAL("FIXME: NOP gate not implemented");
}

void codegen_cc::comment(const std::string &c)
{
    if(verboseCode) emit(c.c_str());
}

/************************************************************************\
| Classical operations on kernels
\************************************************************************/

void codegen_cc::ifStart(size_t op0, const std::string &opName, size_t op1)
{
    comment(SS2S("# IF_START(R" << op0 << " " << opName << " R" << op1 << ")"));
    FATAL("FIXME: not implemented");
}

void codegen_cc::elseStart(size_t op0, const std::string &opName, size_t op1)
{
    comment(SS2S("# ELSE_START(R" << op0 << " " << opName << " R" << op1 << ")"));
    FATAL("FIXME: not implemented");
}

void codegen_cc::forStart(const std::string &label, int iterations)
{
    comment(SS2S("# FOR_START(" << iterations << ")"));
    // FIXME: reserve register
    emit("", "move", SS2S(iterations << ",R62"), "# R62 is the 'for loop counter'");        // FIXME: fixed reg, no nested loops
    emit((label+":").c_str(), "", SS2S(""), "# ");        // just a label
}

void codegen_cc::forEnd(const std::string &label)
{
    comment("# FOR_END");
    // FIXME: free register
    emit("", "loop", SS2S("R62,@" << label), "# R62 is the 'for loop counter'");        // FIXME: fixed reg, no nested loops
}

void codegen_cc::doWhileStart(const std::string &label)
{
    comment("# DO_WHILE_START");
    emit((label+":").c_str(), "", SS2S(""), "# ");                              // NB: just a label
}

void codegen_cc::doWhileEnd(const std::string &label, size_t op0, const std::string &opName, size_t op1)
{
    comment(SS2S("# DO_WHILE_END(R" << op0 << " " << opName << " R" << op1 << ")"));
    emit("", "jmp", SS2S("@" << label), "# FIXME: we don't support conditions, just an endless loop'");        // FIXME: just endless loop
}

/************************************************************************\
|
| private functions
|
\************************************************************************/

/************************************************************************\
| Some helpers to ease nice assembly formatting
\************************************************************************/

void codegen_cc::emit(const char *labelOrComment, const char *instr)
{
    if(!labelOrComment || strlen(labelOrComment)==0) {  // no label
        codeSection << "        " << instr << std::endl;
    } else if(strlen(labelOrComment)<8) {               // label fits before instr
        codeSection << std::setw(8) << labelOrComment << instr << std::endl;
    } else if(strlen(instr)==0) {                       // no instr
        codeSection << labelOrComment << std::endl;
    } else {
        codeSection << labelOrComment << std::endl << "        " << instr << std::endl;
    }
}


// @param   label       must include trailing ":"
// @param   comment     must include leading "#"
// FIXME: label is also used for CCIO selector
void codegen_cc::emit(const char *label, const char *instr, const std::string &ops, const char *comment)
{
    codeSection << std::setw(16) << label << std::setw(16) << instr << std::setw(24) << ops << comment << std::endl;
}


void codegen_cc::emitDp(const std::string &sel, const std::string &statement, const std::string &comment)
{
    datapathSection << std::setw(16) << sel << std::setw(16) << statement << std::setw(24) << comment << std::endl;
}




// FIXME: assure space between fields!
// FIXME: also provide the above with std::string parameters

/************************************************************************\
| helpers
\************************************************************************/

void codegen_cc::emitProgramStart()
{
#if OPT_FEEDBACK
    emit(".CODE");   // start .CODE section
#endif

    comment("# synchronous start and latency compensation");

    // user settable delay via register
#if OPT_OLD_SEQBAR_SEMANTICS  // original seq_bar semantics
    // FIXME: is 'seq_bar 1' safe in the sense that we will never get an empty queue?
    emit("",                "add",      "R63,1,R0",         "# R63 externally set by user, prevent 0 value which would wrap counter");
    emit("",                "seq_bar",  "20",               "# synchronization");
    emit("syncLoop:",       "seq_out",  "0x00000000,1",     "# 20 ns delay");
    emit("",                "loop",     "R0,@syncLoop",     "# ");
#else  // new seq_bar semantics (firmware from 20191219 onwards)
    emit("",                "seq_bar",  "",                 "# synchronization, delay set externally through SET_SEQ_BAR_CNT");
#endif

    emit("mainLoop:",       "",         "",                 "# ");

#if OPT_FEEDBACK
    // initialize state
    emit("",                "seq_state","0",                "# clear Programmable Logic state");
#endif
}


void codegen_cc::padToCycle(size_t lastEndCycle, size_t startCycle, int slot, const std::string &instrumentName)
{
    // compute prePadding: time to bridge to align timing
    int prePadding = startCycle - lastEndCycle;
    if(prePadding < 0) {
        EOUT("Inconsistency detected in bundle contents: printing code generated so far");
        EOUT(codeSection.str());        // show what we made. FIXME: limit # lines
        FATAL("Inconsistency detected in bundle contents: time travel not yet possible in this version: prePadding=" << prePadding <<
              ", startCycle=" << startCycle <<
              ", lastEndCycle=" << lastEndCycle <<
              ", instrumentName='" << instrumentName << "'");
    }

    if(prePadding > 0) {     // we need to align
        emit(SS2S("[" << slot << "]").c_str(),      // CCIO selector
            "seq_out",
            SS2S("0x00000000," << prePadding),
            SS2S("# cycle " << lastEndCycle << "-" << startCycle << ": padding on '" << instrumentName+"'").c_str());
    }
}


#if !OPT_SUPPORT_STATIC_CODEWORDS
uint32_t codegen_cc::assignCodeword(const std::string &instrumentName, int instrIdx, int group)
{
    uint32_t codeword;
    std::string signalValue = bi->signalValue;

    if(JSON_EXISTS(codewordTable, instrumentName) &&                    // instrument exists
                    codewordTable[instrumentName].size() > group) {     // group exists
        bool cwFound = false;
        // try to find signalValue
        json &myCodewordArray = codewordTable[instrumentName][group];
        for(codeword=0; codeword<myCodewordArray.size() && !cwFound; codeword++) {   // NB: JSON find() doesn't work for arrays
            if(myCodewordArray[codeword] == signalValue) {
                DOUT("signal value found at cw=" << codeword);
                cwFound = true;
            }
        }
        if(!cwFound) {
            std::string msg = SS2S("signal value '" << signalValue
                    << "' not found in group " << group
                    << ", which contains " << myCodewordArray);
            if(mapPreloaded) {
                FATAL("mismatch between preloaded 'backend_cc_map_input_file' and program requirements:" << msg)
            } else {
                DOUT(msg);
                // NB: codeword already contains last used value + 1
                // FIXME: check that number is available
                myCodewordArray[codeword] = signalValue;                    // NB: structure created on demand
            }
        }
    } else {    // new instrument or group
        if(mapPreloaded) {
            FATAL("mismatch between preloaded 'backend_cc_map_input_file' and program requirements: instrument '"
                  << instrumentName << "', group "
                  << group
                  << " not present in file");
        } else {
            codeword = 1;
            codewordTable[instrumentName][group][0] = "";                   // code word 0 is empty
            codewordTable[instrumentName][group][codeword] = signalValue;   // NB: structure created on demand
        }
    }
    return codeword;
}
#endif


// compute signalValueString, and some meta information, for sd[s] (i.e. one of the signals in the JSON definition of an instruction)
codegen_cc::tCalcSignalValue codegen_cc::calcSignalValue(const settings_cc::tSignalDef &sd, size_t s, const std::vector<size_t> &qops, const std::string &iname)
{   tCalcSignalValue ret;
    std::string signalSPath = SS2S(sd.path<<"["<<s<<"]");                   // for JSON error reporting

    // get the operand index & qubit to work on
    ret.operandIdx = json_get<unsigned int>(sd.signal[s], "operand_idx", signalSPath);
    if(ret.operandIdx >= qops.size()) {
        JSON_FATAL("instruction '" << iname <<
              "': illegal operand number " << ret.operandIdx <<
              "' exceeds expected maximum of " << qops.size()-1 <<
              "(edit JSON, or provide enough parameters)");                 // FIXME: add offending statement
    }
    unsigned int qubit = qops[ret.operandIdx];

    // get signalInfo via signal type (e.g. "mw", "flux", etc. NB: this is different from
    // the type provided by find_instruction_type, although some identical strings are used) FIXME: it seems that key "instruction/type" is no longer used by the 'core' of OpenQL
    std::string instructionSignalType = json_get<std::string>(sd.signal[s], "type", signalSPath);
    ret.si = settings.findSignalInfoForQubit(instructionSignalType, qubit);

    // get signal value
    const json instructionSignalValue = json_get<const json>(sd.signal[s], "value", signalSPath);   // NB: json_get<const json&> unavailable

#if OPT_CROSSCHECK_INSTRUMENT_DEF
    // verify dimensions
    size_t channelsPergroup = ret.si.ic.controlModeGroupSize;
    if(instructionSignalValue.size() != channelsPergroup) {
        JSON_FATAL("signal dimension mismatch on instruction '" << iname <<
                   "' : control mode '" << ret.si.ic.refControlMode <<
                   "' requires " <<  channelsPergroup <<
                   " signals, but signal '" << signalSPath+"/value" <<
                   "' provides " << instructionSignalValue.size());
    }
#endif

    // expand macros
    ret.signalValueString = SS2S(instructionSignalValue);   // serialize instructionSignalValue into std::string
    utils::replace(ret.signalValueString, std::string("\""), std::string(""));   // get rid of quotes
    utils::replace(ret.signalValueString, std::string("{gateName}"), iname);
    utils::replace(ret.signalValueString, std::string("{instrumentName}"), ret.si.ic.ii.instrumentName);
    utils::replace(ret.signalValueString, std::string("{instrumentGroup}"), std::to_string(ret.si.group));
    // FIXME: allow using all qubits involved (in same signalType?, or refer to signal: qubitOfSignal[n]), e.g. qubit[0], qubit[1], qubit[2]
    utils::replace(ret.signalValueString, std::string("{qubit}"), std::to_string(qubit));

    // FIXME: note that the actual contents of the signalValue only become important when we'll do automatic codeword assignment and provide codewordTable to downstream software to assign waveforms to the codewords

    comment(SS2S("  # slot=" << ret.si.ic.ii.slot
            << ", instrument='" << ret.si.ic.ii.instrumentName << "'"
            << ", group=" << ret.si.group
            << "': signalValue='" << ret.signalValueString << "'"
            ));

    return ret;
}


} // namespace ql
