/**
 * @file    arch/cc/pass/gen/vq1asm/detail/codegen.cc
 * @date    201810xx
 * @author  Wouter Vlothuizen (wouter.vlothuizen@tno.nl)
 * @brief   code generator backend for the Central Controller
 * @note    here we don't check whether the sequence of calling code generator
 *          functions is correct
 */

#include "codegen.h"

#include "ql/version.h"
#include "ql/com/options.h"
#include "ql/ir/describe.h"

#include <iosfwd>

namespace ql {
namespace arch {
namespace cc {
namespace pass {
namespace gen {
namespace vq1asm {
namespace detail {

using namespace utils;

/************************************************************************\
| Generic
\************************************************************************/

void Codegen::init(const ir::PlatformRef &platform, const OptionsRef &options) {
    // NB: a new eqasm_backend_cc is instantiated per call to compile, and
    // as a result also a codegen_cc, so we don't need to cleanup
    this->platform = platform;
    this->options = options;
#if 1
    // based on NewToOldConverter::NewToOldConverter
    // FIXME: bit expensive to go back to old
    settings.loadBackendSettings(
        ir::compat::Platform::build(
            platform->name,
            platform->data.data)
    );
#else
    settings = platform->get_annotation<pass::gen::vq1asm::detail::Settings>();  // NB: set in Info::post_process_platform() FIXME: will that retain the platform member var
#endif

    // optionally preload codewordTable
    Str map_input_file = options->map_input_file;
    if (!map_input_file.empty()) {
        QL_DOUT("loading map_input_file='" << map_input_file << "'");
        Json map = load_json(map_input_file);
        codewordTable = map["codeword_table"];      // FIXME: use json_get
        mapPreloaded = true;
    }

#if OPT_FEEDBACK
    // iterate over instruments
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        const Settings::InstrumentControl ic = settings.getInstrumentControl(instrIdx);
        if (QL_JSON_EXISTS(ic.controlMode, "result_bits")) {  // this instrument mode produces results (i.e. it is a measurement device)
            QL_IOUT("instrument '" << ic.ii.instrumentName << "' (index " << instrIdx << ") is used for feedback");
        }
    }
#endif
}

Str Codegen::getProgram() {
#if OPT_FEEDBACK
    return codeSection.str() + dp.getDatapathSection();
#else
    return codeSection.str();
#endif
}

Str Codegen::getMap() {
    Json map;

    map["note"] = "generated by OpenQL CC backend version " CC_BACKEND_VERSION_STRING;
    map["codeword_table"] = codewordTable;
    return QL_SS2S(std::setw(4) << map << std::endl);
}


/************************************************************************\
| 'Program' level functions
\************************************************************************/

void Codegen::programStart(const Str &progName) {
    emitProgramStart(progName);

    dp.programStart();

    // Determine number of qubits.
    utils::UInt num_qubits;
    if (platform->qubits->shape.size() == 1) {
        num_qubits = platform->qubits->shape[0];
    } else {
        QL_USER_ERROR("main qubit register has wrong dimensionality");
    };

    // Get cycle time from old Platform (NB: in new Platform, all durations are in cycles, not ns).
    utils::UInt cycle_time = platform->data.data["hardware_settings"]["cycle_time"];     // FIXME: check JSON access

    vcd.programStart(num_qubits, cycle_time, MAX_GROUPS, settings);
}


void Codegen::programFinish(const Str &progName) {
    emitProgramFinish();

    dp.programFinish();

    vcd.programFinish(options->output_prefix + ".vcd");
}

/************************************************************************\
| 'Kernel' level functions
\************************************************************************/

void Codegen::kernelStart(const Str &kernelName) {
    comment(QL_SS2S("### Kernel: '" << kernelName << "'"));
    zero(lastEndCycle); // new IR starts counting at zero
}

void Codegen::kernelFinish(const Str &kernelName, UInt durationInCycles) {
    vcd.kernelFinish(kernelName, durationInCycles);
}

/************************************************************************\
| 'Bundle' level functions
\************************************************************************/

/*
    Our strategy is to first process all customGate's in a bundle, storing the
    relevant information in bundleInfo. Then, when all work for a bundle has
    been collected, we generate code in bundleFinish

    - bundleStart():
    clear bundleInfo, which maintains the work that needs to be performed for bundle

    - customGate():
    collect gate information in bundleInfo

    - bundleFinish():
    generate code for bundle from information collected in bundleInfo (which
    may be empty if no custom gates are present in bundle)
*/

// bundleStart: see 'strategy' above
void Codegen::bundleStart(const Str &cmnt) {
    // create 'matrix' of BundleInfo with proper vector size per instrument
    bundleInfo.clear();
    BundleInfo empty;
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        const Settings::InstrumentControl ic = settings.getInstrumentControl(instrIdx);
        bundleInfo.emplace_back(
            ic.controlModeGroupCnt,     // one BundleInfo per group in the control mode selected for instrument
            empty                       // empty BundleInfo
        );
    }

    // generate source code comments
    comment(cmnt);
    dp.comment(cmnt, options->verbose);      // FIXME: comment is not fully appropriate, but at least allows matching with .CODE section
}




// Static helper function for bundleFinish()
typedef struct {
    tDigital groupDigOut;    // codeword/mask fragment for this group
    Str comment;            // comment for instruction stream
} CalcGroupDigOut;

static CalcGroupDigOut calcGroupDigOut(
        UInt instrIdx,
        UInt group,
        UInt nrGroups,
        const Settings::InstrumentControl &ic,
        tCodeword staticCodewordOverride
) {
    CalcGroupDigOut ret{0, ""};

    // determine control mode group FIXME: more explanation
    Int controlModeGroup = -1;
    if (ic.controlModeGroupCnt == 0) {
        QL_JSON_ERROR("'control_bits' not defined or empty in 'control_modes/" << ic.refControlMode <<"'");
#if OPT_VECTOR_MODE
    } else if (ic.controlModeGroupCnt == 1) {                   // vector mode: group addresses channel within vector
        controlModeGroup = 0;
#endif
    } else if (group < ic.controlModeGroupCnt) {                // normal mode: group selects control group
        controlModeGroup = group;
    } else {
        // NB: this actually an error in program logic
        QL_JSON_ERROR(
            "instrument '" << ic.ii.instrumentName
            << "' uses " << nrGroups
            << " groups, but control mode '" << ic.refControlMode
            << "' only defines " << ic.controlModeGroupCnt
            << " groups in 'control_bits'"
        );
    }

    // get number of control bits for group
    const Json &groupControlBits = ic.controlMode["control_bits"][controlModeGroup];    // NB: tests above guarantee existence
    QL_DOUT(
        "instrumentName=" << ic.ii.instrumentName
        << ", slot=" << ic.ii.slot
        << ", control mode group=" << controlModeGroup
        << ", group control bits: " << groupControlBits
    );
    UInt nrGroupControlBits = groupControlBits.size();


    // calculate digital output for group
    if (nrGroupControlBits == 1) {       // single bit, implying this is a mask (not code word)
        ret.groupDigOut |= 1ul << groupControlBits[0].get<Int>();     // NB: we assume the mask is active high, which is correct for VSM and UHF-QC
        // FIXME: check controlModeGroup vs group
    } else if (nrGroupControlBits > 1) {                 // > 1 bit, implying code word
#if OPT_VECTOR_MODE
        //  allow single code word for vector of groups. FIXME: requires looking at all sd.signal before assigning code word
        if (group != controlModeGroup) {
            // FIXME: unfinished work on vector mode
        }
#endif

        // find or assign code word
        tCodeword codeword = 0;
        Bool codewordOverriden = false;
#if OPT_SUPPORT_STATIC_CODEWORDS
        codeword = staticCodewordOverride;
        codewordOverriden = true;
#else
        codeword = assignCodeword(ic.ii.instrumentName, instrIdx, group);
#endif

        // convert codeword to digOut
        for (size_t idx=0; idx<nrGroupControlBits; idx++) {
            Int codeWordBit = nrGroupControlBits - 1 - idx;    // NB: groupControlBits defines MSB..LSB
            if (codeword & (1ul << codeWordBit)) {
                ret.groupDigOut |= 1ul << groupControlBits[idx].get<Int>();
            }
        }

        ret.comment = QL_SS2S(
            "  # slot=" << ic.ii.slot
            << ", instrument='" << ic.ii.instrumentName << "'"
            << ", group=" << group
            << ": codeword=" << codeword
            << std::string(codewordOverriden ? " (static override)" : "")
            << ": groupDigOut=0x" << std::hex << std::setfill('0') << std::setw(8) << ret.groupDigOut
        );
    } else {    // nrGroupControlBits < 1
        QL_JSON_ERROR(
            "key 'control_bits' empty for group " << controlModeGroup
            << " on instrument '" << ic.ii.instrumentName << "'"
        );
    }

    // add trigger to digOut
    UInt nrTriggerBits = ic.controlMode["trigger_bits"].size();
    if (nrTriggerBits == 0) {                                   // no trigger
        // do nothing
    } else if (nrTriggerBits == 1) {                            // single trigger for all groups (NB: will possibly assigned multiple times)
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][0].get<Int>();
#if 1    // FIXME: hotfix for QWG, implement properly
    } else if(nrTriggerBits == 2) {
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][0].get<Int>();
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][1].get<Int>();
#endif
#if 1   // FIXME: trigger per group
    } else if(nrTriggerBits == nrGroups) {                      // trigger per group
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][group].get<Int>();
#endif
    } else {
        QL_JSON_ERROR(
            "instrument '" << ic.ii.instrumentName
            << "' uses " << nrGroups
            << " groups, but control mode '" << ic.refControlMode
            << "' defines " << nrTriggerBits
            << " trigger bits in 'trigger_bits' (must be 1 or #groups)"
        );
    }

    return ret;
}


Codegen::CodeGenMap Codegen::collectCodeGenInfo(
    UInt startCycle,
    UInt durationInCycles
) {
    CodeGenMap codeGenMap;

    // iterate over instruments
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        // get control info from instrument settings
        const Settings::InstrumentControl ic = settings.getInstrumentControl(instrIdx);
        if (ic.ii.slot >= MAX_SLOTS) {
            QL_JSON_ERROR(
                "illegal slot " << ic.ii.slot
                << " on instrument '" << ic.ii.instrumentName
            );
        }

        /************************************************************************\
        | collect code generation info from all groups within one instrument
        \************************************************************************/

        // FIXME: the term 'group' is used in a diffused way: 1) index of signal vectors, 2) controlModeGroup

        CodeGenInfo codeGenInfo = {false};

        // remind information needed for code generation
        codeGenInfo.instrumentName = ic.ii.instrumentName;
        codeGenInfo.slot = ic.ii.slot;

        // now collect code generation info from all groups of instrument
        UInt nrGroups = bundleInfo[instrIdx].size();
        for (UInt group = 0; group < nrGroups; group++) {
            const BundleInfo &bi = bundleInfo[instrIdx][group];           // shorthand

            // handle output
            if (!bi.signalValue.empty()) {                         // signal defined, i.e.: we need to output something
                // compute maximum duration over all groups
                if (bi.durationInCycles > codeGenInfo.instrMaxDurationInCycles) {
                    codeGenInfo.instrMaxDurationInCycles = bi.durationInCycles;
                }

                CalcGroupDigOut gdo = calcGroupDigOut(instrIdx, group, nrGroups, ic, bi.staticCodewordOverride);
                codeGenInfo.digOut |= gdo.groupDigOut;
                comment(gdo.comment);
#if OPT_FEEDBACK
                // conditional gates
                // store condition and groupDigOut in condMap, if all groups are unconditional we use old scheme, otherwise
                // datapath is configured to generate proper digital output
                if (bi.condition == ConditionType::ALWAYS || ic.ii.forceCondGatesOn) {
                    // nothing to do, just use digOut
                } else {    // other conditions, including cond_never
                    // remind mapping for setting PL
                    codeGenInfo.condGateMap.emplace(group, CondGateInfo{bi.condition, bi.cond_operands, gdo.groupDigOut});
                }
#endif

                vcd.bundleFinishGroup(startCycle, bi.durationInCycles, gdo.groupDigOut, bi.signalValue, instrIdx, group);

                codeGenInfo.instrHasOutput = true;
            } // if(signal defined)


#if OPT_PRAGMA
            // handle pragma
            if (bi.pragma) {
                // FIXME: enforce single pragma per bundle (currently by design)
                // FIXME: enforce no other work
                codeGenInfo.pragma = bi.pragma;

                // FIXME: use breg_operands if present? How about qubit (operand) then?
                UInt breg_operand = bi.operands[0];                    // implicit classic bit for qubit. FIXME: perform checks
                // get SM bit for classic operand (allocated during readout)
                codeGenInfo.pragmaSmBit = dp.getSmBit(breg_operand, instrIdx);
            }
#endif


#if OPT_FEEDBACK
            // handle readout (i.e. when necessary, create feedbackMap entry
            // NB: we allow for instruments that perform the input side of readout only, without signal generation by the
            // same instrument, which might be needed in the future
            // FIXME: also generate VCD

            if (bi.isMeasFeedback) {
                UInt resultBit = Settings::getResultBit(ic, group);

#if 0    // FIXME: partly redundant
                // get our qubit
                const Json qubits = json_get<const Json>(*ic.ii.instrument, "qubits", ic.ii.instrumentName);   // NB: json_get<const Json&> unavailable
                UInt qubitGroupCnt = qubits.size();                                  // NB: JSON key qubits is a 'matrix' of [groups*qubits]
                if (group >= qubitGroupCnt) {    // FIXME: also tested in settings_cc::findSignalInfoForQubit
                    QL_JSON_ERROR("group " << group << " not defined in '" << ic.ii.instrumentName << "/qubits'");
                }
                const Json qubitsOfGroup = qubits[group];
                if (qubitsOfGroup.size() != 1) {    // FIXME: not tested elsewhere
                    QL_JSON_ERROR("group " << group << " of '" << ic.ii.instrumentName << "/qubits' should define 1 qubit, not " << qubitsOfGroup.size());
                }
                Int qubit = qubitsOfGroup[0].get<Int>();
                if (bi.readoutQubit != qubit) {              // this instrument group handles requested qubit. FIXME: inherently true
                    QL_ICE("inconsistency FIXME");
                };
#endif
                // get classic operand
                UInt breg_operand;
                if (bi.breg_operands.empty()) {
                    breg_operand = bi.operands[0];                    // implicit classic bit for qubit
                    QL_IOUT("Using implicit bit " << breg_operand << " for qubit " << bi.operands[0]);
                } else {
                    breg_operand = bi.breg_operands[0];
                    QL_IOUT("Using explicit bit " << breg_operand << " for qubit " << bi.operands[0]);
                }

                // allocate SM bit for classic operand
                UInt smBit = dp.allocateSmBit(breg_operand, instrIdx);

                // remind mapping of bit -> smBit for setting MUX
                codeGenInfo.feedbackMap.emplace(group, FeedbackInfo{smBit, resultBit, bi});
            }
#endif
        } // for(group)
        codeGenMap.set(instrIdx) = codeGenInfo;
     } // for(instrIdx)
     return codeGenMap;
}


// bundleFinish: see 'strategy' above
void Codegen::bundleFinish(
    UInt startCycle,
    UInt durationInCycles,
    Bool isLastBundle
) {
    // collect info for all instruments
    CodeGenMap codeGenMap = collectCodeGenInfo(startCycle, durationInCycles);

    // compute stuff requiring overview over all instruments:
    // FIXME: add
    // - DSM used, for seq_inv_sm

    // determine whether bundle has any feedback
    Bool bundleHasFeedback = false;
    for (const auto &codeGenInfo : codeGenMap) {
        if (!codeGenInfo.second.feedbackMap.empty()) {
            bundleHasFeedback = true;
            // FIXME: calc min and max SM address used
            //  unsigned int smAddr = datapath_cc::getMuxSmAddr(feedbackMap);
        }
    }

    // turn code generation info collected above into actual code
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        CodeGenInfo codeGenInfo = codeGenMap.at(instrIdx);

        if (isLastBundle && instrIdx == 0) {
            comment(QL_SS2S(" # last bundle of kernel, will pad outputs to match durations"));
        }

        // generate code for instrument output
        if (codeGenInfo.instrHasOutput) {
            emitOutput(
                codeGenInfo.condGateMap,
                codeGenInfo.digOut,
                codeGenInfo.instrMaxDurationInCycles,
                instrIdx,
                startCycle,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );
        } else {    // !instrHasOutput
            // nothing to do, we delay emitting till a slot is used or kernel finishes (i.e. isLastBundle just below)
        }

#if OPT_PRAGMA
        if (codeGenInfo.pragma) {    // NB: note that this will only work because we set the pragma for all instruments, and thus already encounter this for the first instrument FIXME: update comment
            emitPragma(
                *codeGenInfo.pragma,
                codeGenInfo.pragmaSmBit,
                instrIdx,
                startCycle,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );
        }
#endif

#if OPT_FEEDBACK
        if (bundleHasFeedback) {
            emitFeedback(
                codeGenInfo.feedbackMap,
                instrIdx,
                startCycle,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );
        }
#endif

        // for last bundle, pad end of bundle to align durations
        if (isLastBundle) {
            emitPadToCycle(
                instrIdx, startCycle + durationInCycles,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );        // FIXME: use instrMaxDurationInCycles and/or check consistency
        }

        vcd.bundleFinish(
            startCycle,
            codeGenInfo.digOut,
            codeGenInfo.instrMaxDurationInCycles,
            instrIdx
        );    // FIXME: conditional gates, etc
    } // for(instrIdx)

    comment("");    // blank line to separate bundles
}

/************************************************************************\
| Quantum instructions
\************************************************************************/

// helper
static Str qasm(const Str &iname, const Vec<UInt> &operands, const Vec<UInt> &breg_operands) {
    // FIXME: hack
    ir::compat::gate_types::Custom g(iname);
    g.operands = operands;
    g.breg_operands = breg_operands;
    return g.qasm();
}

// customGate: single/two/N qubit gate, including readout, see 'strategy' above
// translates 'gate' representation to 'waveform' representation (BundleInfo) and maps qubits to instruments & group.
// Does not deal with the control mode and digital interface of the instrument.
void Codegen::customGate(
    const Str &iname,
    const Vec<UInt> &operands,
    const Vec<UInt> &creg_operands,
    const Vec<UInt> &breg_operands,
    ConditionType condition,
    const Vec<UInt> &cond_operands,
    Real angle,
    UInt startCycle, UInt durationInCycles
) {
#if 0   // FIXME: test for angle parameter
    if(angle != 0.0) {
        QL_DOUT("iname=" << iname << ", angle=" << angle);
    }
#endif

    vcd.customGate(iname, operands, startCycle, durationInCycles);

    Bool isReadout = settings.isReadout(iname);        //  determine whether this is a readout instruction

    // generate comment
    if (isReadout) {
        comment(Str(" # READOUT: '") + qasm(iname, operands, breg_operands) + "'");
    } else { // handle all other instruction types than "readout"
        // generate comment. NB: we don't have a particular limit for the number of operands
        comment(Str(" # gate '") + qasm(iname, operands, breg_operands) + "'");
    }

#if 0   // FIXME: org
    // find instruction (gate definition)
    const Json &instruction = platform->find_instruction(iname);
#else
    // find instruction (gate definition) in JSON platform data
    const Json &instruction = platform->data.data["instructions"][iname];     // FIXME: check JSON access. FIXME: how about generalizations/specializations
#endif
    // find signal vector definition for instruction
    Settings::SignalDef sd = settings.findSignalDefinition(instruction, iname);

    // scatter signals defined for instruction (e.g. several operands and/or types) to instruments & groups
    for (UInt s = 0; s < sd.signal.size(); s++) {
        CalcSignalValue csv = calcSignalValue(sd, s, operands, iname);

        // store signal value, checking for conflicts
        BundleInfo &bi = bundleInfo[csv.si.instrIdx][csv.si.group];         // shorthand
        if (!csv.signalValueString.empty()) {                               // empty implies no signal
            if (bi.signalValue.empty()) {                                   // signal not yet used
                bi.signalValue = csv.signalValueString;
#if OPT_SUPPORT_STATIC_CODEWORDS
                // FIXME: this does not only provide support, but findStaticCodewordOverride() currently actually requires static codewords
                bi.staticCodewordOverride = Settings::findStaticCodewordOverride(instruction, csv.operandIdx, iname); // NB: function return -1 means 'no override'
#endif
            } else if (bi.signalValue == csv.signalValueString) {           // signal unchanged
                // do nothing
            } else {
                showCodeSoFar();
                QL_USER_ERROR(
                    "Signal conflict on instrument='" << csv.si.ic.ii.instrumentName
                    << "', group=" << csv.si.group
                    << ", between '" << bi.signalValue
                    << "' and '" << csv.signalValueString << "'"
                );  // FIXME: add offending instruction
            }
        }

        // store signal duration
        bi.durationInCycles = durationInCycles;

#if OPT_FEEDBACK
        // FIXME: assumes that group configuration for readout input matches that of output
        // store operands used for readout, actual work is postponed to bundleFinish()
        if (isReadout) {
            /*
             * kernel->gate allows 3 types of measurement:
             *         - no explicit result. Historically this implies either:
             *             - no result, measurement results are often read offline from the readout device (mostly the raw values
             *             instead of the binary result), without the control device ever taking notice of the value
             *             - implicit bit result for qubit, e.g. for the CC-light using conditional gates
             *         - creg result (old, no longer valid)
             *             note that Creg's are managed through a class, whereas bregs are just numbers
             *         - breg result (new)
             */

            // operand checks
            if (operands.size() != 1) {
                QL_INPUT_ERROR(
                    "Readout instruction '" << qasm(iname, operands, breg_operands)
                    << "' requires exactly 1 quantum operand, not " << operands.size()
                );
            }
            if (!creg_operands.empty()) {
                QL_INPUT_ERROR("Using Creg as measurement target is deprecated, use new breg_operands");
            }
            if (breg_operands.size() > 1) {
                QL_INPUT_ERROR(
                    "Readout instruction '" << qasm(iname, operands, breg_operands)
                    << "' requires 0 or 1 bit operands, not " << breg_operands.size()
                );
            }

            // store operands
            if (settings.getReadoutMode(iname)=="feedback") {
                bi.isMeasFeedback = true;
                bi.operands = operands;
                //bi.creg_operands = creg_operands;    // NB: will be empty because of checks performed earlier
                bi.breg_operands = breg_operands;
            }
        }

        // store 'expression' for conditional gates
        bi.condition = condition;
        bi.cond_operands = cond_operands;
#endif

        QL_DOUT("customGate(): iname='" << iname <<
             "', duration=" << durationInCycles <<
             " [cycles], instrIdx=" << csv.si.instrIdx <<
             ", group=" << csv.si.group);

        // NB: code is generated in bundleFinish()
    }   // for(signal)

#if OPT_PRAGMA
    RawPtr<const Json> pragma = settings.getPragma(iname);
    if (pragma) {
        for (Vec<BundleInfo> &vbi : bundleInfo) {
            // FIXME: for now we just store the JSON of the pragma statement in bundleInfo[*][0]
            if(vbi[0].pragma) {
                QL_INPUT_ERROR("Bundle contains more than one gate with 'pragma' key");    // FIXME: provide context
            }
            vbi[0].pragma = pragma;

            // store operands
            vbi[0].operands = operands;
            //vbi[0].creg_operands = creg_operands;    // NB: will be empty because of checks performed earlier
            vbi[0].breg_operands = breg_operands;
        }
    }
#endif
}

void Codegen::nopGate() {
    comment("# NOP gate");
    QL_ICE("FIXME: NOP gate not implemented");
}

/************************************************************************\
| Classical operations on kernels
\************************************************************************/

#if 0   // FIXME
void Codegen::ifStart(UInt op0, const Str &opName, UInt op1) {
    comment(QL_SS2S("# IF_START(R" << op0 << " " << opName << " R" << op1 << ")"));
    QL_ICE("FIXME: not implemented");
}

void Codegen::elseStart(UInt op0, const Str &opName, UInt op1) {
    comment(QL_SS2S("# ELSE_START(R" << op0 << " " << opName << " R" << op1 << ")"));
    QL_ICE("FIXME: not implemented");
}

void Codegen::forStart(const Str &label, UInt iterations) {
    comment(QL_SS2S("# FOR_START(" << iterations << ")"));
    // FIXME: reserve register
    emit("", "move", QL_SS2S(iterations << ",R62"), "# R62 is the 'for loop counter'");        // FIXME: fixed reg, no nested for loops (not supported by program.cc either)
    emit((label+":"), "", "", "# ");
#if OPT_PRAGMA
    pragmaLoopLabel.push_back(label);        // remind label for pragma/break FIXME: implement properly later on
#endif
}

void Codegen::forEnd(const Str &label) {
    comment("# FOR_END");
    // FIXME: free register
    emit("", "loop", QL_SS2S("R62,@" << label), "# R62 is the 'for loop counter'");        // FIXME: fixed reg, no nested for loops (not supported by program.cc either)
#if OPT_PRAGMA
    emit((label+"_end:"), "", "", "# ");    // label for 'break'
    pragmaLoopLabel.pop_back();
#endif
}

void Codegen::doWhileStart(const Str &label) {
    comment("# DO_WHILE_START");
    emit((label+":"), "", "", "# ");
#if OPT_PRAGMA
    pragmaLoopLabel.push_back(label);        // remind label for pragma/break FIXME: implement properly later on
#endif
}

void Codegen::doWhileEnd(const Str &label, UInt op0, const Str &opName, UInt op1) {
    comment(QL_SS2S("# DO_WHILE_END(R" << op0 << " " << opName << " R" << op1 << ")"));
    emit("", "jmp", QL_SS2S("@" << label), "# FIXME: we don't support conditions, just an endless loop'");        // FIXME: just endless loop
    QL_WOUT("CC backend ignores condition of do while loop");
#if OPT_PRAGMA
    emit((label+"_end:"), "", "", "# ");    // label for 'break'
    pragmaLoopLabel.pop_back();
#endif
}

#else
void Codegen::for_start(const OperandContext &operandContext, const ir::ExpressionRef &condition, const Str &label_start, const Str &label_end) {
    comment("# FOR_START");
    emit(label_start+":");
    handle_expression(operandContext, condition, label_end, "for.condition");
    // FIXME: handle condition 'true'
    // FIXME: jmp loop end if false
}


#endif

void Codegen::comment(const Str &c) {
    if (options->verbose) emit(c);
}

/************************************************************************\
| new IR expressions
\************************************************************************/

void Codegen::handle_set_instruction(const OperandContext &operandContext, const ir::SetInstruction &set, const Str &descr)
{
    QL_IOUT(descr << ": '" << ir::describe(set) << "'");

    int lhs;
    try {
        lhs = operandContext.convert_creg_reference(set.lhs);
        // FIXME: also allow breg?
    } catch (utils::Exception &e) {
        e.add_context("unsupported LHS for set instruction encountered");
        throw;
    }

    do_handle_expression(operandContext, set.rhs, set.lhs, "", descr);

}

void Codegen::handle_expression(const OperandContext &operandContext, const ir::ExpressionRef &expression, const Str &label_if_false, const Str &descr)
{
    QL_IOUT(descr << ": '" << ir::describe(expression) << "'");
    do_handle_expression(operandContext, expression, One<ql::ir::Expression>(), label_if_false, descr);
}


/************************************************************************\
|
| private functions
|
\************************************************************************/

/************************************************************************\
| Some helpers to ease nice assembly formatting
\************************************************************************/

// FIXME: assure space between fields!
// FIXME: make comment output depend on verboseCode

void Codegen::emit(const Str &labelOrComment, const Str &instr) {
    if (labelOrComment.empty()) {                       // no label
        codeSection << "        " << instr << std::endl;
    } else if (labelOrComment.length() < 8) {           // label fits before instr
        codeSection << std::setw(8) << labelOrComment << instr << std::endl;
    } else if (instr.empty()) {                         // no instr
        codeSection << labelOrComment << std::endl;
    } else {
        codeSection << labelOrComment << std::endl << "        " << instr << std::endl;
    }
}


// @param   labelOrSel      label must include trailing ":"
// @param   comment         must include leading "#"
void Codegen::emit(const Str &labelOrSel, const Str &instr, const Str &ops, const Str &comment) {
    codeSection << std::setw(16) << labelOrSel << std::setw(16) << instr << std::setw(24) << ops << comment << std::endl;
}

void Codegen::emit(Int slot, const Str &instr, const Str &ops, const Str &comment) {
    emit(QL_SS2S("[" << slot << "]"), instr, ops, comment);
}

/************************************************************************\
| helpers
\************************************************************************/

void Codegen::showCodeSoFar() {
    // provide context to help finding reason. FIXME: limit # lines
    QL_EOUT("Code so far:\n" << codeSection.str());
}

void Codegen::emitProgramStart(const Str &progName) {
    // emit program header
    codeSection << std::left;    // assumed by emit()
    codeSection << "# Program: '" << progName << "'" << std::endl;   // NB: put on top so it shows up in internal CC logging
    codeSection << "# CC_BACKEND_VERSION " << CC_BACKEND_VERSION_STRING << std::endl;
    codeSection << "# OPENQL_VERSION " << OPENQL_VERSION_STRING << std::endl;
    codeSection << "# Note:    generated by OpenQL Central Controller backend" << std::endl;
    codeSection << "#" << std::endl;

#if OPT_FEEDBACK
    emit(".CODE");   // start .CODE section
#endif

    // NB: new seq_bar semantics (firmware from 20191219 onwards)
    comment("# synchronous start and latency compensation");
    emit("",                "seq_bar",  "",                 "# synchronization, delay set externally through SET_SEQ_BAR_CNT");
    emit("",                "seq_out",  "0x00000000,1",     "# allows monitoring actual start time using trace unit");
    emit("__mainLoop:",     "",         "",                 "# ");    // FIXME: __mainLoop should be a forbidden kernel name

#if OPT_FEEDBACK
    // initialize state
    emit("",                "seq_state","0",                "# clear Programmable Logic state");
#endif
}


void Codegen::emitProgramFinish() {
    if (options->run_once) {   // program runs once only
        emit("", "stop");
    } else {   // CC-light emulation: loop indefinitely
        // prevent real time pipeline emptying during jmp below (especially in conjunction with pragma/break
        emit("", "seq_wait", "1", "");

        // loop indefinitely
        emit("",      // no CCIO selector
             "jmp",
             "@__mainLoop",
             "# loop indefinitely");
    }

    emit(".END");   // end .CODE section
}


// generate code to input measurement results and distribute them via DSM
void Codegen::emitFeedback(
    const FeedbackMap &feedbackMap,
    UInt instrIdx,
    UInt startCycle,
    Int slot,
    const Str &instrumentName
) {
    if (startCycle > lastEndCycle[instrIdx]) {  // i.e. if(!instrHasOutput)
        emitPadToCycle(instrIdx, startCycle, slot, instrumentName);
    }

    // code generation for participating and non-participating instruments (NB: must take equal number of sequencer cycles)
    if (!feedbackMap.empty()) {    // this instrument performs readout for feedback now
        UInt mux = dp.getOrAssignMux(instrIdx, feedbackMap);
        dp.emitMux(mux, feedbackMap, instrIdx, slot);

        // emit code for slot input
        UInt sizeTag = Datapath::getSizeTag(feedbackMap.size());        // compute DSM transfer size tag (for 'seq_in_sm' instruction)
        UInt smAddr = Datapath::getMuxSmAddr(feedbackMap);
        emit(
            slot,
            "seq_in_sm",
            QL_SS2S("S" << smAddr << ","  << mux << "," << sizeTag),
            QL_SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << lastEndCycle[instrIdx]+1 << ": feedback on '" << instrumentName+"'")
        );
        lastEndCycle[instrIdx]++;
    } else {    // this instrument does not perform readout for feedback now
        // emit code for non-participating instrument
        // FIXME: may invalidate DSM that ust arrived dependent on individual SEQBAR counts
        UInt smAddr = 0;
        UInt smTotalSize = 1;    // FIXME: inexact, but me must not invalidate memory that we will not write
        emit(
            slot,
            "seq_inv_sm",
            QL_SS2S("S" << smAddr << ","  << smTotalSize),
            QL_SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << lastEndCycle[instrIdx]+1 << ": invalidate SM on '" << instrumentName+"'")
        );
        lastEndCycle[instrIdx]++;
    }
}


void Codegen::emitOutput(
        const CondGateMap &condGateMap,
        tDigital digOut,
        UInt instrMaxDurationInCycles,
        UInt instrIdx,
        UInt startCycle,
        Int slot,
        const Str &instrumentName
) {
    comment(QL_SS2S(
        "  # slot=" << slot
        << ", instrument='" << instrumentName << "'"
        << ": lastEndCycle=" << lastEndCycle[instrIdx]
        << ", startCycle=" << startCycle
        << ", instrMaxDurationInCycles=" << instrMaxDurationInCycles
    ));

    emitPadToCycle(instrIdx, startCycle, slot, instrumentName);

    // emit code for slot output
    if (condGateMap.empty()) {    // all groups unconditional
        emit(
            slot,
            "seq_out",
            QL_SS2S("0x" << std::hex << std::setfill('0') << std::setw(8) << digOut << std::dec << "," << instrMaxDurationInCycles),
            QL_SS2S("# cycle " << startCycle << "-" << startCycle + instrMaxDurationInCycles << ": code word/mask on '" << instrumentName + "'")
        );
    } else {    // at least one group conditional
        // configure datapath PL
        UInt pl = dp.getOrAssignPl(instrIdx, condGateMap);
        UInt smAddr = dp.emitPl(pl, condGateMap, instrIdx, slot);

        // emit code for conditional gate
        emit(
            slot,
            "seq_out_sm",
            QL_SS2S("S" << smAddr << "," << pl << "," << instrMaxDurationInCycles),
            QL_SS2S("# cycle " << startCycle << "-" << startCycle + instrMaxDurationInCycles << ": conditional code word/mask on '" << instrumentName << "'")
        );
    }

    // update lastEndCycle
    lastEndCycle[instrIdx] = startCycle + instrMaxDurationInCycles;
}

void Codegen::emitPragma(
    const Json &pragma,
    Int pragmaSmBit,
    UInt instrIdx,
    UInt startCycle,
    Int slot,
    const Str &instrumentName
) {
    if (startCycle > lastEndCycle[instrIdx]) {    // i.e. if(!instrHasOutput)
        emitPadToCycle(instrIdx, startCycle, slot, instrumentName);
    }

    // FIXME: the only pragma possible is "break" for now
    Int pragmaBreakVal = json_get<Int>(pragma, "break", "pragma of unknown instruction");        // FIXME: we don't know which instruction we're dealing with, so better move
    UInt smAddr = pragmaSmBit / 32;    // 'seq_cl_sm' is addressable in 32 bit words
    UInt mask = 1ul << (pragmaSmBit % 32);
    std::string label = pragmaLoopLabel.back() + "_end";        // FIXME: must match label set in forEnd(), assumes we are actually inside a for loop

    // emit code for pragma "break". NB: code is identical for all instruments
    // FIXME: verify that instruction duration matches actual time
/*
    seq_cl_sm   S<address>          ; pass 32 bit SM-data to Q1 ...
    seq_wait    3                   ; prevent starvation of real time part during instructions below: 4 classic instructions + 1 branch
    move_sm     R0                  ; ... and move to register
    nop                             ; register dependency R0
    and         R0,<mask>,R1        ; mask depends on DSM bit location
    nop                             ; register dependency R1
    jlt         R1,1,@loop
*/
    emit(slot, "seq_cl_sm", QL_SS2S("S" << smAddr), QL_SS2S("# 'break if " << pragmaBreakVal << "' on '" << instrumentName << "'"));
    emit(slot, "seq_wait", "3", "");
    emit(slot, "move_sm", "R0", "");
    emit(slot, "nop", "", "");
    emit(slot, "and", QL_SS2S("R0," << mask << "," << "R1"), "");    // results in '0' for 'bit==0' and 'mask' for 'bit==1'
    emit(slot, "nop", "", "");
    if (pragmaBreakVal == 0) {
        emit(slot, "jlt", QL_SS2S("R1,1,@" << label), "");
    } else {
        emit(slot, "jge", QL_SS2S("R1,1,@" << label), "");
    }
}


void Codegen::emitPadToCycle(UInt instrIdx, UInt startCycle, Int slot, const Str &instrumentName) {
    // compute prePadding: time to bridge to align timing
    int prePadding = startCycle - lastEndCycle[instrIdx];
    if (prePadding < 0) {
        QL_EOUT("Inconsistency detected in bundle contents: printing code generated so far");
        showCodeSoFar();
        QL_INPUT_ERROR(
            "Inconsistency detected in bundle contents: time travel not yet possible in this version: prePadding=" << prePadding
            << ", startCycle=" << startCycle
            << ", lastEndCycle=" << lastEndCycle[instrIdx]
            << ", instrumentName='" << instrumentName << "'"
            << ", instrIdx=" << instrIdx
        );
    }

    if (prePadding > 0) {     // we need to align
        emit(
            slot,
            "seq_wait",
            QL_SS2S(prePadding),
            QL_SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << startCycle << ": padding on '" << instrumentName+"'")
        );
    }

    // update lastEndCycle
    lastEndCycle[instrIdx] = startCycle;
}


// compute signalValueString, and some meta information, for sd[s] (i.e. one of the signals in the JSON definition of an instruction)
Codegen::CalcSignalValue Codegen::calcSignalValue(
    const Settings::SignalDef &sd,
    UInt s,
    const Vec<UInt> &operands,
    const Str &iname
) {
    CalcSignalValue ret;
    Str signalSPath = QL_SS2S(sd.path<<"["<<s<<"]");                   // for JSON error reporting

    /************************************************************************\
    | get signal properties, mapping operand index to qubit
    \************************************************************************/

    // get the operand index & qubit to work on
    ret.operandIdx = json_get<UInt>(sd.signal[s], "operand_idx", signalSPath);
    if (ret.operandIdx >= operands.size()) {
        QL_JSON_ERROR(
            "instruction '" << iname
            << "': JSON file defines operand_idx " << ret.operandIdx
            << ", but only " << operands.size()
            << " operands were provided (correct JSON, or provide enough operands)"
        ); // FIXME: add offending statement
    }
    UInt qubit = operands[ret.operandIdx];

    // get signal value
    const Json instructionSignalValue = json_get<const Json>(sd.signal[s], "value", signalSPath);   // NB: json_get<const Json&> unavailable
    Str sv = QL_SS2S(instructionSignalValue);   // serialize/stream instructionSignalValue into std::string

    // get instruction signal type (e.g. "mw", "flux", etc)
    // NB: instructionSignalType is different from "instruction/type" provided by find_instruction_type, although some identical strings are used). NB: that key is no longer used by the 'core' of OpenQL
    Str instructionSignalType = json_get<Str>(sd.signal[s], "type", signalSPath);

    /************************************************************************\
    | map signal type for qubit to instrument & group
    \************************************************************************/

    // find signalInfo, i.e. perform the mapping
    ret.si = settings.findSignalInfoForQubit(instructionSignalType, qubit);

    if (instructionSignalValue.empty()) {    // allow empty signal
        ret.signalValueString = "";
    } else {
        // verify signal dimensions
        UInt channelsPergroup = ret.si.ic.controlModeGroupSize;
        if (instructionSignalValue.size() != channelsPergroup) {
            QL_JSON_ERROR(
                "signal dimension mismatch on instruction '" << iname
                << "' : control mode '" << ret.si.ic.refControlMode
                << "' requires " <<  channelsPergroup
                << " signals, but signal '" << signalSPath+"/value"
                << "' provides " << instructionSignalValue.size()
            );
        }

        // expand macros
        sv = replace_all(sv, "\"", "");   // get rid of quotes
        sv = replace_all(sv, "{gateName}", iname);
        sv = replace_all(sv, "{instrumentName}", ret.si.ic.ii.instrumentName);
        sv = replace_all(sv, "{instrumentGroup}", to_string(ret.si.group));
        // FIXME: allow using all qubits involved (in same signalType?, or refer to signal: qubitOfSignal[n]), e.g. qubit[0], qubit[1], qubit[2]
        sv = replace_all(sv, "{qubit}", to_string(qubit));
        ret.signalValueString = sv;

        // FIXME: note that the actual contents of the signalValue only become important when we'll do automatic codeword assignment and provide codewordTable to downstream software to assign waveforms to the codewords
    }

    comment(QL_SS2S(
        "  # slot=" << ret.si.ic.ii.slot
        << ", instrument='" << ret.si.ic.ii.instrumentName << "'"
        << ", group=" << ret.si.group
        << "': signalValue='" << ret.signalValueString << "'"
    ));

    return ret;
}


#if !OPT_SUPPORT_STATIC_CODEWORDS
Codeword codegen_cc::assignCodeword(const Str &instrumentName, Int instrIdx, Int group) {
    Codeword codeword;
    Str signalValue = bi->signalValue;

    if (QL_JSON_EXISTS(codewordTable, instrumentName) &&                        // instrument exists
                    codewordTable[instrumentName].size() > group) {         // group exists
        Bool cwFound = false;
        // try to find signalValue
        Json &myCodewordArray = codewordTable[instrumentName][group];
        for (codeword = 0; codeword < myCodewordArray.size() && !cwFound; codeword++) {   // NB: JSON find() doesn't work for arrays
            if (myCodewordArray[codeword] == signalValue) {
                QL_DOUT("signal value found at cw=" << codeword);
                cwFound = true;
            }
        }
        if (!cwFound) {
            Str msg = QL_SS2S("signal value '" << signalValue
                    << "' not found in group " << group
                    << ", which contains " << myCodewordArray);
            if (mapPreloaded) {
                QL_USER_ERROR("mismatch between preloaded 'backend_cc_map_input_file' and program requirements:" << msg)
            } else {
                QL_DOUT(msg);
                // NB: codeword already contains last used value + 1
                // FIXME: check that number is available
                myCodewordArray[codeword] = signalValue;                    // NB: structure created on demand
            }
        }
    } else {    // new instrument or group
        if (mapPreloaded) {
            QL_USER_ERROR("mismatch between preloaded 'backend_cc_map_input_file' and program requirements: instrument '"
                  << instrumentName << "', group "
                  << group
                  << " not present in file");
        } else {
            codeword = 1;
            codewordTable[instrumentName][group][0] = "";                   // code word 0 is empty
            codewordTable[instrumentName][group][codeword] = signalValue;   // NB: structure created on demand
        }
    }
    return codeword;
}
#endif

/************************************************************************\
| expression helpers
\************************************************************************/

// FIXME: recursion?
// FIXME: or pass SetInstruction or Expression depending on use
// FIXME: adopt structure of cQASM's cqasm-v1-functions-gen.cpp register_into used for constant propagation

/* Actually perform the code generation for an expression. Can be called to handle:
 * - the RHS of a SetInstruction, in which case parameter 'lhs' must be valid
 * - an Expression that acts as a condition for loop control, in which case parameter 'label_if_false' must contain
 * the label to jump to if the expression evaluates as false
 * The distinction between the two modes of operation is made based on the type of expression, either 'bit' or 'int',
 * which is possible because of the rather strict separation between these two types
 */
void Codegen::do_handle_expression(
    const OperandContext &operandContext,
    const ir::ExpressionRef &expression,
    const ir::ExpressionRef &lhs,
    const Str &label_if_false,
    const Str &descr
) {
    // helper
    auto dest_reg = [operandContext, lhs]() { return operandContext.convert_creg_reference(lhs); };

    try {
        if (auto ilit = expression->as_int_literal()) {
            emit(
                "",
                "move",
                QL_SS2S(ilit->value << ",R" << dest_reg())
                , "# " + ir::describe(expression)
            );
        } else if (expression->as_reference()) {
            if(operandContext.is_creg_reference(expression)) {
                auto creg = operandContext.convert_creg_reference(expression);
                emit(
                    "",
                    "move",
                    QL_SS2S("R" << creg << ",R" << dest_reg())  // FIXME: use op_str_int?
                    , "# " + ir::describe(expression)
                );
            } else {
                auto breg = operandContext.convert_breg_reference(expression);
                // FIXME, see Codegen::emitPragma for cast of bit to int
            }
        } else if (auto fn = expression->as_function_call()) {
            // helpers to convert expression operand to Q1 instruction argument
            auto op_str_int = [operandContext](const ir::ExpressionRef &op) {
                if(op->as_reference()) {
                    return QL_SS2S("R" << operandContext.convert_creg_reference(op));
                } else if(op->as_int_literal()) {
                    return QL_SS2S(op->as_int_literal()->value);
                } else {
                    QL_ICE("Expected integer operand");
                }
            };
            auto op_str_bit = [operandContext](const ir::ExpressionRef &op) {
                if(op->as_reference()) {
                    return QL_SS2S("R" << operandContext.convert_breg_reference(op));
                } else if(op->as_int_literal()) {   // FIXME: do literals make sense here
                    return QL_SS2S(op->as_int_literal()->value);
                } else {
                    QL_ICE("Expected bit operand");
                }
            };
            // helpers
            enum Profile {
//                X,      // unknown/unsupported
//                LL,
                LR,     // int Literal, Reference
                RL,
                RR
            };
            auto get_profile = [](Any<ir::Expression> operands) {
//                if(operands[0]->as_int_literal() && operands[1]->as_int_literal()) {
//                    return LL;
//                } else
                if(operands[0]->as_int_literal() && operands[1]->as_reference()) {
                    return LR;
                } else if(operands[0]->as_reference() && operands[1]->as_int_literal()) {
                    return RL;
                } else if(operands[0]->as_reference() && operands[1]->as_reference()) {
                    return RR;
                } else if(operands[0]->as_function_call()) {
                    QL_INPUT_ERROR("cannot handle function call within function call '" << ir::describe(operands[0]) << "'");
                    // FIXME: etc, also handle "creg(0)=creg(0)+1+1" or "1 < i+3"
                } else if(operands[1]->as_function_call()) {
                    QL_INPUT_ERROR("cannot handle function call within function call '" << ir::describe(operands[1]) << "'");
                } else {
                    QL_INPUT_ERROR("cannot handle parameter combination '" << ir::describe(operands[0]) << "' , '" << ir::describe(operands[1]) << "'");
                    // NB: includes both parameters being int_literal, which we may handle in the future by a separate pass
                }
            };
            auto emit_2op = [this, op_str_int, fn, expression](const Str &mnem, Int arg0, Int arg1, const Str &target="R63") {  // FIXME: default target R63
                emit(
                    "",
                    mnem,
                    QL_SS2S(
                        op_str_int(fn->operands[arg0])
                        << "," << op_str_int(fn->operands[arg1])
                        << "," << target
                    )
                    , "# " + ir::describe(expression)
                );
            };
            // ----------- end of helpers -------------

            utils::Str operation;

            // handle cast
            if (fn->function_type->name == "int") {
                CHECK_COMPAT(
                    fn->operands.size() == 1 &&
                    fn->operands[0]->as_function_call(),
                    "'int()' cast target must be a function"
                );
                fn = fn->operands[0]->as_function_call();   // FIXME: step into. Shouldn't we recurse to allow e.g. casting a breg??
            }

            // int arithmetic, 1 operand
            if (fn->function_type->name == "operator~") {
                operation = "not";
                emit(
                    "",
                    operation,
                    QL_SS2S(
                        op_str_int(fn->operands[0])
                        << ",R" << dest_reg()
                    )
                    , "# " + ir::describe(expression)
                );
            }

            // bit arithmetic, 1 operand
            if (fn->function_type->name == "operator!") {
                operation = "not";
                op_str_bit(fn->operands[0]);
                // FIXME, see Codegen::emitPragma for cast of bit to int
            }

            // int arithmetic, 2 operands
            if (operation.empty()) {    // check group only if nothing found yet
                if (fn->function_type->name == "operator+") {
                    operation = "add";
                } else if (fn->function_type->name == "operator-") {
                    operation = "sub";
                } else if (fn->function_type->name == "operator&") {
                    operation = "and";
                } else if (fn->function_type->name == "operator|") {
                    operation = "or";
                } else if (fn->function_type->name == "operator^") {
                    operation = "xor";
                }
                if (!operation.empty()) {
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_2op(operation, 0, 1); break;
                        case LR:    emit_2op(operation, 1, 0); break;   // reverse operands to match Q1 instruction set
                            if (operation == "sub") {
                                // FIXME: correct for changed op order
                            }
                    }
                }
            }

            // bool/bit arithmetic, 2 operands
            if(operation.empty()) {
                if (fn->function_type->name == "operator&&") {
                    operation = "FIXME";
                } else if (fn->function_type->name == "operator||") {
                    operation = "FIXME";
                } else if (fn->function_type->name == "operator^^") {
                    operation = "FIXME";
                }
                if (!operation.empty()) {
                    auto arg0 = op_str_bit(fn->operands[0]);
                    auto arg1 = op_str_bit(fn->operands[1]);
                    // FIXME, see Codegen::emitPragma for cast of bit to int
                }
            }

            // relop, group 1
            if(operation.empty()) {
                if (fn->function_type->name == "operator==") {
                    operation = "jge";
                } else if (fn->function_type->name == "operator!=") {
                    operation = "jlt";
                }
                if(!operation.empty()) {
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_2op("xor", 0, 1); break;
                        case LR:    emit_2op("xor", 1, 0); break;   // reverse operands to match Q1 instruction set
                    }
                    emit("", "nop", "", "");    // register dependency
                    emit("", operation, "R63,1,@"+label_if_false, "");   // FIXME: R63
                }
            }

            // relop, group 2
            if(operation.empty()) {
                if (fn->function_type->name == "operator>=") {
                    operation = ">=";   // NB: actual contents unused here
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_2op("jge", 0, 1, "@"+label_if_false); break;
                        case LR:    emit_2op("jlt", 1, 0), "@"+label_if_false; break;   // reverse operands (and instruction) to match Q1 instruction set
                    }
                } else if (fn->function_type->name == "operator<") {
                    operation = "<";
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_2op("jlt", 0, 1, "@"+label_if_false); break;
                        case LR:    emit_2op("jge", 1, 0), "@"+label_if_false; break;   // reverse operands (and instruction) to match Q1 instruction set
                    }
                } else if (fn->function_type->name == "operator>") {
                    operation = ">";
                    switch (get_profile(fn->operands)) {
                        case RL:    emit(
                                        "",
                                        "jge",
                                        QL_SS2S(
                                            op_str_int(fn->operands[0])
                                            << fn->operands[1]->as_int_literal()->value + 1    // increment literal since we lack 'jgt'
                                            << ",@"+label_if_false
                                        )
                                    );
                                    break;
                        case RR:    emit(
                                        "",
                                        "add",
                                        QL_SS2S(
                                            "1,"
                                            << op_str_int(fn->operands[1])
                                            << ",R63"
                                        )
                                    );                      // increment arg1
                                    emit("", "nop", "");    // register dependency
                                    emit(
                                        "",
                                        "jge",
                                        QL_SS2S(
                                            op_str_int(fn->operands[0])
                                            << ",R63"               // FIXME: R63
                                            << ",@"+label_if_false
                                        )
                                    );
                                    break;
                        case LR:    emit(
                                        "",
                                        "jlt",                              // reverse instruction
                                        QL_SS2S(
                                            op_str_int(fn->operands[1])     // reverse operands
                                            << fn->operands[0]->as_int_literal()->value - 1    // DECrement literal since we lack 'jle'
                                            << ",@"+label_if_false
                                        )
                                    );
                                    break;
                    }
                } else if (fn->function_type->name == "operator<=") {
                    operation = "<=";
                    // FIXME
                }
                if(!operation.empty()) {
                    // NB: all work done above
                }
            }

            if(operation.empty()) {
                // NB: we'll only see functions 'registered' through add_function_type() in
                // 'Ref convert_old_to_new(const compat::PlatformRef &old)', other functions are eliminated by libqasm's
                // contant propagation if possible, and otherwise raise an error.
                // If we arrive here, there's an unintended inconsistency between the registered functions and our
                // decoding
                QL_ICE(
                    "function '" << fn->function_type->name << "' not supported by CC backend, but it should be"
                );
            }
        }
    }
    catch (utils::Exception &e) {
        e.add_context("in expression '" + ir::describe(expression) + "'", true);
        throw;
    }

}


} // namespace detail
} // namespace vq1asm
} // namespace gen
} // namespace pass
} // namespace cc
} // namespace arch
} // namespace ql
