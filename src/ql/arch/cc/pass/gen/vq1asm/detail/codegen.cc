/**
 * @file    arch/cc/pass/gen/vq1asm/detail/codegen.cc
 * @date    201810xx
 * @author  Wouter Vlothuizen (wouter.vlothuizen@tno.nl)
 * @brief   code generator backend for the Central Controller
 * @note    here we don't check whether the sequence of calling code generator
 *          functions is correct
 */

#include "codegen.h"

#include "ql/version.h"
#include "ql/com/options.h"
#include "ql/ir/describe.h"
#include "ql/ir/ops.h"

#include <iosfwd>

namespace ql {
namespace arch {
namespace cc {
namespace pass {
namespace gen {
namespace vq1asm {
namespace detail {

using namespace utils;

// helpers for label generation.
Str to_start(const Str &base) { return base + "_start"; };
Str to_end(const Str &base) { return base + "_end"; };
Str to_ifbranch(const Str &base, Int branch) { return QL_SS2S(base << "_" << branch); }
Str as_label(const Str &label) { return label + ":"; }
Str as_target(const Str &label) { return "@" + label; }


Codegen::Codegen(const ir::Ref &ir, const OptionsRef &options)
    : ir(ir)
    , options(options)
    , operandContext(ir)
{
    init(); // FIXME: inline, or make private
}

/************************************************************************\
| Generic
\************************************************************************/

void Codegen::init() {
    // NB: a new Backend is instantiated per call to compile, and
    // as a result also a Codegen, so we don't need to cleanup

#if 1
#if 0
    settings.loadBackendSettings(ir->platform);
#else
    // based on NewToOldConverter::NewToOldConverter
    // FIXME: bit expensive to go back to old
    settings.loadBackendSettings(
        ir::compat::Platform::build(
            ir->platform->name,
            ir->platform->data.data)
    );
#endif
#else
    settings = platform->get_annotation<pass::gen::vq1asm::detail::Settings>();  // NB: set in Info::post_process_platform() FIXME: will that retain the platform member var
#endif

    // optionally preload codewordTable
    Str map_input_file = options->map_input_file;
    if (!map_input_file.empty()) {
        QL_DOUT("loading map_input_file='" << map_input_file << "'");
        Json map = load_json(map_input_file);
        codewordTable = map["codeword_table"];      // FIXME: use json_get
        mapPreloaded = true;
    }

#if OPT_FEEDBACK
    // iterate over instruments
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        const Settings::InstrumentControl ic = settings.getInstrumentControl(instrIdx);
        if (QL_JSON_EXISTS(ic.controlMode, "result_bits")) {  // this instrument mode produces results (i.e. it is a measurement device)
            QL_IOUT("instrument '" << ic.ii.instrumentName << "' (index " << instrIdx << ") is used for feedback");
        }
    }
#endif
}

Str Codegen::getProgram() {
#if OPT_FEEDBACK
    return codeSection.str() + dp.getDatapathSection();
#else
    return codeSection.str();
#endif
}

Str Codegen::getMap() {
    Json map;

    map["note"] = "generated by OpenQL CC backend version " CC_BACKEND_VERSION_STRING;
    map["codeword_table"] = codewordTable;
    return QL_SS2S(std::setw(4) << map << std::endl);
}


/************************************************************************\
| 'Program' level functions
\************************************************************************/

void Codegen::programStart(const Str &progName) {
    emitProgramStart(progName);

    dp.programStart();

    // Determine number of qubits.
    utils::UInt num_qubits;
    if (ir->platform->qubits->shape.size() == 1) {
        num_qubits = ir->platform->qubits->shape[0];
    } else {
        QL_USER_ERROR("main qubit register has wrong dimensionality");
    };

    // Get cycle time from old Platform (NB: in new Platform, all durations are in cycles, not ns).
    utils::UInt cycle_time = ir->platform->data.data["hardware_settings"]["cycle_time"];     // FIXME: check JSON access

    vcd.programStart(num_qubits, cycle_time, MAX_GROUPS, settings);
}


void Codegen::programFinish(const Str &progName) {
    emitProgramFinish();

    dp.programFinish();

    vcd.programFinish(options->output_prefix + ".vcd");
}

/************************************************************************\
| 'Block' (fka 'Kernel', this name stays relevant as it is used by the
| API) level functions
\************************************************************************/

void Codegen::block_start(const Str &block_name) {
    comment(QL_SS2S("### Block: '" << block_name << "'"));
    zero(lastEndCycle); // NB; new IR starts counting at zero
}

void Codegen::block_finish(const Str &block_name, UInt durationInCycles) {
    comment(QL_SS2S("### Block end: '" << block_name << "'"));
    vcd.kernelFinish(block_name, durationInCycles);
}

/************************************************************************\
| 'Bundle' level functions. Although the new IR no longer organizes
| instructions in Bundles, we still need to process them as such, i.e.
| evaluate all instructions issued in the same cycle together.
\************************************************************************/

/*
    Our strategy is to first process all customGate's in a bundle, storing the
    relevant information in bundleInfo. Then, when all work for a bundle has
    been collected, we generate code in bundleFinish

    - bundleStart():
    clear bundleInfo, which maintains the work that needs to be performed for bundle

    - customGate():
    collect gate information in bundleInfo

    - bundleFinish():
    generate code for bundle from information collected in bundleInfo (which
    may be empty if no custom gates are present in bundle)
*/

// bundleStart: see 'strategy' above
void Codegen::bundleStart(const Str &cmnt) {
    // create 'matrix' of BundleInfo with proper vector size per instrument
    bundleInfo.clear();
    BundleInfo empty;
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        const Settings::InstrumentControl ic = settings.getInstrumentControl(instrIdx);
        bundleInfo.emplace_back(
            ic.controlModeGroupCnt,     // one BundleInfo per group in the control mode selected for instrument
            empty                       // empty BundleInfo
        );
    }

    // generate source code comments
    comment(cmnt);
    dp.comment(cmnt, options->verbose);      // FIXME: comment is not fully appropriate, but at least allows matching with .CODE section
}




// Static helper function for bundleFinish()
typedef struct {
    tDigital groupDigOut;    // codeword/mask fragment for this group
    Str comment;            // comment for instruction stream
} CalcGroupDigOut;

static CalcGroupDigOut calcGroupDigOut(
        UInt instrIdx,
        UInt group,
        UInt nrGroups,
        const Settings::InstrumentControl &ic,
        tCodeword staticCodewordOverride
) {
    CalcGroupDigOut ret{0, ""};

    // determine control mode group FIXME: more explanation
    Int controlModeGroup = -1;
    if (ic.controlModeGroupCnt == 0) {
        QL_JSON_ERROR("'control_bits' not defined or empty in 'control_modes/" << ic.refControlMode <<"'");
#if OPT_VECTOR_MODE
    } else if (ic.controlModeGroupCnt == 1) {                   // vector mode: group addresses channel within vector
        controlModeGroup = 0;
#endif
    } else if (group < ic.controlModeGroupCnt) {                // normal mode: group selects control group
        controlModeGroup = group;
    } else {
        // NB: this actually an error in program logic
        QL_JSON_ERROR(
            "instrument '" << ic.ii.instrumentName
            << "' uses " << nrGroups
            << " groups, but control mode '" << ic.refControlMode
            << "' only defines " << ic.controlModeGroupCnt
            << " groups in 'control_bits'"
        );
    }

    // get number of control bits for group
    const Json &groupControlBits = ic.controlMode["control_bits"][controlModeGroup];    // NB: tests above guarantee existence
    QL_DOUT(
        "instrumentName=" << ic.ii.instrumentName
        << ", slot=" << ic.ii.slot
        << ", control mode group=" << controlModeGroup
        << ", group control bits: " << groupControlBits
    );
    UInt nrGroupControlBits = groupControlBits.size();


    // calculate digital output for group
    if (nrGroupControlBits == 1) {       // single bit, implying this is a mask (not code word)
        ret.groupDigOut |= 1ul << groupControlBits[0].get<Int>();     // NB: we assume the mask is active high, which is correct for VSM and UHF-QC
        // FIXME: check controlModeGroup vs group
    } else if (nrGroupControlBits > 1) {                 // > 1 bit, implying code word
#if OPT_VECTOR_MODE
        //  allow single code word for vector of groups. FIXME: requires looking at all sd.signal before assigning code word
        if (group != controlModeGroup) {
            // FIXME: unfinished work on vector mode
        }
#endif

        // find or assign code word
        tCodeword codeword = 0;
        Bool codewordOverriden = false;
#if OPT_SUPPORT_STATIC_CODEWORDS
        codeword = staticCodewordOverride;
        codewordOverriden = true;
#else
        codeword = assignCodeword(ic.ii.instrumentName, instrIdx, group);
#endif

        // convert codeword to digOut
        for (size_t idx=0; idx<nrGroupControlBits; idx++) {
            Int codeWordBit = nrGroupControlBits - 1 - idx;    // NB: groupControlBits defines MSB..LSB
            if (codeword & (1ul << codeWordBit)) {
                ret.groupDigOut |= 1ul << groupControlBits[idx].get<Int>();
            }
        }

        ret.comment = QL_SS2S(
            "  # slot=" << ic.ii.slot
            << ", instrument='" << ic.ii.instrumentName << "'"
            << ", group=" << group
            << ": codeword=" << codeword
            << std::string(codewordOverriden ? " (static override)" : "")
            << ": groupDigOut=0x" << std::hex << std::setfill('0') << std::setw(8) << ret.groupDigOut
        );
    } else {    // nrGroupControlBits < 1
        QL_JSON_ERROR(
            "key 'control_bits' empty for group " << controlModeGroup
            << " on instrument '" << ic.ii.instrumentName << "'"
        );
    }

    // add trigger to digOut
    UInt nrTriggerBits = ic.controlMode["trigger_bits"].size();
    if (nrTriggerBits == 0) {                                   // no trigger
        // do nothing
    } else if (nrTriggerBits == 1) {                            // single trigger for all groups (NB: will possibly assigned multiple times)
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][0].get<Int>();
#if 1    // FIXME: hotfix for QWG, implement properly
    } else if(nrTriggerBits == 2) {
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][0].get<Int>();
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][1].get<Int>();
#endif
#if 1   // FIXME: trigger per group
    } else if(nrTriggerBits == nrGroups) {                      // trigger per group
        ret.groupDigOut |= 1ul << ic.controlMode["trigger_bits"][group].get<Int>();
#endif
    } else {
        QL_JSON_ERROR(
            "instrument '" << ic.ii.instrumentName
            << "' uses " << nrGroups
            << " groups, but control mode '" << ic.refControlMode
            << "' defines " << nrTriggerBits
            << " trigger bits in 'trigger_bits' (must be 1 or #groups)"
        );
    }

    return ret;
}


Codegen::CodeGenMap Codegen::collectCodeGenInfo(
    UInt startCycle,
    UInt durationInCycles
) {
    CodeGenMap codeGenMap;

    // iterate over instruments
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        // get control info from instrument settings
        const Settings::InstrumentControl ic = settings.getInstrumentControl(instrIdx);
        if (ic.ii.slot >= MAX_SLOTS) {
            QL_JSON_ERROR(
                "illegal slot " << ic.ii.slot
                << " on instrument '" << ic.ii.instrumentName
            );
        }

        /************************************************************************\
        | collect code generation info from all groups within one instrument
        \************************************************************************/

        // FIXME: the term 'group' is used in a diffused way: 1) index of signal vectors, 2) controlModeGroup

        CodeGenInfo codeGenInfo = {false};

        // remind information needed for code generation
        codeGenInfo.instrumentName = ic.ii.instrumentName;
        codeGenInfo.slot = ic.ii.slot;

        // now collect code generation info from all groups of instrument
        UInt nrGroups = bundleInfo[instrIdx].size();
        for (UInt group = 0; group < nrGroups; group++) {
            const BundleInfo &bi = bundleInfo[instrIdx][group];           // shorthand

            // handle output
            if (!bi.signalValue.empty()) {                         // signal defined, i.e.: we need to output something
                // compute maximum duration over all groups
                if (bi.durationInCycles > codeGenInfo.instrMaxDurationInCycles) {
                    codeGenInfo.instrMaxDurationInCycles = bi.durationInCycles;
                }

                CalcGroupDigOut gdo = calcGroupDigOut(instrIdx, group, nrGroups, ic, bi.staticCodewordOverride);
                codeGenInfo.digOut |= gdo.groupDigOut;
                comment(gdo.comment);
#if OPT_FEEDBACK
                // conditional gates
                // store condition and groupDigOut in condMap, if all groups are unconditional we use old scheme, otherwise
                // datapath is configured to generate proper digital output
                if (bi.condition == ConditionType::ALWAYS || ic.ii.forceCondGatesOn) {
                    // nothing to do, just use digOut
                } else {    // other conditions, including cond_never
                    // remind mapping for setting PL
                    codeGenInfo.condGateMap.emplace(group, CondGateInfo{bi.condition, bi.cond_operands, gdo.groupDigOut});
                }
#endif

                vcd.bundleFinishGroup(startCycle, bi.durationInCycles, gdo.groupDigOut, bi.signalValue, instrIdx, group);

                codeGenInfo.instrHasOutput = true;
            } // if(signal defined)


#if OPT_PRAGMA
            // handle pragma
            if (bi.pragma) {
                // FIXME: enforce single pragma per bundle (currently by design)
                // FIXME: enforce no other work
                codeGenInfo.pragma = bi.pragma;

                // FIXME: use breg_operands if present? How about qubit (operand) then?
                UInt breg_operand = bi.operands[0];                    // implicit classic bit for qubit. FIXME: perform checks
                // get SM bit for classic operand (allocated during readout)
                codeGenInfo.pragmaSmBit = dp.getSmBit(breg_operand, instrIdx);
            }
#endif


#if OPT_FEEDBACK
            // handle readout (i.e. when necessary, create feedbackMap entry
            // NB: we allow for instruments that perform the input side of readout only, without signal generation by the
            // same instrument, which might be needed in the future
            // FIXME: also generate VCD

            if (bi.isMeasFeedback) {
                UInt resultBit = Settings::getResultBit(ic, group);

#if 0    // FIXME: partly redundant
                // get our qubit
                const Json qubits = json_get<const Json>(*ic.ii.instrument, "qubits", ic.ii.instrumentName);   // NB: json_get<const Json&> unavailable
                UInt qubitGroupCnt = qubits.size();                                  // NB: JSON key qubits is a 'matrix' of [groups*qubits]
                if (group >= qubitGroupCnt) {    // FIXME: also tested in settings_cc::findSignalInfoForQubit
                    QL_JSON_ERROR("group " << group << " not defined in '" << ic.ii.instrumentName << "/qubits'");
                }
                const Json qubitsOfGroup = qubits[group];
                if (qubitsOfGroup.size() != 1) {    // FIXME: not tested elsewhere
                    QL_JSON_ERROR("group " << group << " of '" << ic.ii.instrumentName << "/qubits' should define 1 qubit, not " << qubitsOfGroup.size());
                }
                Int qubit = qubitsOfGroup[0].get<Int>();
                if (bi.readoutQubit != qubit) {              // this instrument group handles requested qubit. FIXME: inherently true
                    QL_ICE("inconsistency FIXME");
                };
#endif
                // get classic operand
                UInt breg_operand;
                if (bi.breg_operands.empty()) {
                    breg_operand = bi.operands[0];                    // implicit classic bit for qubit
                    QL_IOUT("Using implicit bit " << breg_operand << " for qubit " << bi.operands[0]);
                } else {
                    breg_operand = bi.breg_operands[0];
                    QL_IOUT("Using explicit bit " << breg_operand << " for qubit " << bi.operands[0]);
                }

                // allocate SM bit for classic operand
                UInt smBit = dp.allocateSmBit(breg_operand, instrIdx);

                // remind mapping of bit -> smBit for setting MUX
                codeGenInfo.feedbackMap.emplace(group, FeedbackInfo{smBit, resultBit, bi});
            }
#endif
        } // for(group)
        codeGenMap.set(instrIdx) = codeGenInfo;
     } // for(instrIdx)
     return codeGenMap;
}


// bundleFinish: see 'strategy' above
void Codegen::bundleFinish(
    UInt startCycle,
    UInt durationInCycles,
    Bool isLastBundle
) {
    // collect info for all instruments
    CodeGenMap codeGenMap = collectCodeGenInfo(startCycle, durationInCycles);

    // compute stuff requiring overview over all instruments:
    // FIXME: add
    // - DSM used, for seq_inv_sm

    // determine whether bundle has any feedback
    Bool bundleHasFeedback = false;
    for (const auto &codeGenInfo : codeGenMap) {
        if (!codeGenInfo.second.feedbackMap.empty()) {
            bundleHasFeedback = true;
            // FIXME: calc min and max SM address used
            //  unsigned int smAddr = datapath_cc::getMuxSmAddr(feedbackMap);
        }
    }

    // turn code generation info collected above into actual code
    for (UInt instrIdx = 0; instrIdx < settings.getInstrumentsSize(); instrIdx++) {
        CodeGenInfo codeGenInfo = codeGenMap.at(instrIdx);

        if (isLastBundle && instrIdx == 0) {
            comment(QL_SS2S(" # last bundle of kernel, will pad outputs to match durations"));
        }

        // generate code for instrument output
        if (codeGenInfo.instrHasOutput) {
            emitOutput(
                codeGenInfo.condGateMap,
                codeGenInfo.digOut,
                codeGenInfo.instrMaxDurationInCycles,
                instrIdx,
                startCycle,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );
        } else {    // !instrHasOutput
            // nothing to do, we delay emitting till a slot is used or kernel finishes (i.e. isLastBundle just below)
        }

#if OPT_PRAGMA
        if (codeGenInfo.pragma) {    // NB: note that this will only work because we set the pragma for all instruments, and thus already encounter this for the first instrument FIXME: update comment
            emitPragma(
                *codeGenInfo.pragma,
                codeGenInfo.pragmaSmBit,
                instrIdx,
                startCycle,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );
        }
#endif

#if OPT_FEEDBACK
        if (bundleHasFeedback) {
            emitFeedback(
                codeGenInfo.feedbackMap,
                instrIdx,
                startCycle,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );
        }
#endif

        // for last bundle, pad end of bundle to align durations
        if (isLastBundle) {
            emitPadToCycle(
                instrIdx, startCycle + durationInCycles,
                codeGenInfo.slot,
                codeGenInfo.instrumentName
            );        // FIXME: use instrMaxDurationInCycles and/or check consistency
        }

        vcd.bundleFinish(
            startCycle,
            codeGenInfo.digOut,
            codeGenInfo.instrMaxDurationInCycles,
            instrIdx
        );    // FIXME: conditional gates, etc
    } // for(instrIdx)

    comment("");    // blank line to separate bundles
}

/************************************************************************\
| Quantum instructions
\************************************************************************/

// helper
static Str qasm(const Str &iname, const Vec<UInt> &operands, const Vec<UInt> &breg_operands) {
    // FIXME: hack
    ir::compat::gate_types::Custom g(iname);
    g.operands = operands;
    g.breg_operands = breg_operands;
    return g.qasm();
}


// customGate: single/two/N qubit gate, including readout, see 'strategy' above
// translates 'gate' representation to 'waveform' representation (BundleInfo) and maps qubits to instruments & group.
// Does not deal with the control mode and digital interface of the instrument.
void Codegen::customGate(
    const Str &iname,
    const Vec<UInt> &operands,
    const Vec<UInt> &creg_operands,
    const Vec<UInt> &breg_operands,
    ConditionType condition,
    const Vec<UInt> &cond_operands,
    Real angle,
    UInt startCycle, UInt durationInCycles
) {
#if 0   // FIXME: test for angle parameter
    if(angle != 0.0) {
        QL_DOUT("iname=" << iname << ", angle=" << angle);
    }
#endif

    vcd.customGate(iname, operands, startCycle, durationInCycles);

    Bool isReadout = settings.isReadout(iname);        //  determine whether this is a readout instruction

    // generate comment
    if (isReadout) {
        comment(Str(" # READOUT: '") + qasm(iname, operands, breg_operands) + "'");
    } else { // handle all other instruction types than "readout"
        // generate comment. NB: we don't have a particular limit for the number of operands
        comment(Str(" # gate '") + qasm(iname, operands, breg_operands) + "'");
    }

#if 0   // FIXME: org
    // find instruction (gate definition)
    const Json &instruction = platform->find_instruction(iname);
#else
    // find instruction (gate definition) in JSON platform data
    const Json &instruction = ir->platform->data.data["instructions"][iname];     // FIXME: check JSON access. FIXME: how about generalizations/specializations
#endif
    // find signal vector definition for instruction
    Settings::SignalDef sd = settings.findSignalDefinition(instruction, iname);

    // scatter signals defined for instruction (e.g. several operands and/or types) to instruments & groups
    for (UInt s = 0; s < sd.signal.size(); s++) {
        CalcSignalValue csv = calcSignalValue(sd, s, operands, iname);

        // store signal value, checking for conflicts
        BundleInfo &bi = bundleInfo[csv.si.instrIdx][csv.si.group];         // shorthand
        if (!csv.signalValueString.empty()) {                               // empty implies no signal
            if (bi.signalValue.empty()) {                                   // signal not yet used
                bi.signalValue = csv.signalValueString;
#if OPT_SUPPORT_STATIC_CODEWORDS
                // FIXME: this does not only provide support, but findStaticCodewordOverride() currently actually requires static codewords
                bi.staticCodewordOverride = Settings::findStaticCodewordOverride(instruction, csv.operandIdx, iname); // NB: function return -1 means 'no override'
#endif
            } else if (bi.signalValue == csv.signalValueString) {           // signal unchanged
                // do nothing
            } else {
                showCodeSoFar();
                QL_USER_ERROR(
                    "Signal conflict on instrument='" << csv.si.ic.ii.instrumentName
                    << "', group=" << csv.si.group
                    << ", between '" << bi.signalValue
                    << "' and '" << csv.signalValueString << "'"
                );  // FIXME: add offending instruction
            }
        }

        // store signal duration
        bi.durationInCycles = durationInCycles;

#if OPT_FEEDBACK
        // FIXME: assumes that group configuration for readout input matches that of output
        // store operands used for readout, actual work is postponed to bundleFinish()
        if (isReadout) {
            /*
             * kernel->gate allows 3 types of measurement:
             *         - no explicit result. Historically this implies either:
             *             - no result, measurement results are often read offline from the readout device (mostly the raw values
             *             instead of the binary result), without the control device ever taking notice of the value
             *             - implicit bit result for qubit, e.g. for the CC-light using conditional gates
             *         - creg result (old, no longer valid)
             *             note that Creg's are managed through a class, whereas bregs are just numbers
             *         - breg result (new)
             */

            // operand checks
            if (operands.size() != 1) {
                QL_INPUT_ERROR(
                    "Readout instruction '" << qasm(iname, operands, breg_operands)
                    << "' requires exactly 1 quantum operand, not " << operands.size()
                );
            }
            if (!creg_operands.empty()) {
                QL_INPUT_ERROR("Using Creg as measurement target is deprecated, use new breg_operands");
            }
            if (breg_operands.size() > 1) {
                QL_INPUT_ERROR(
                    "Readout instruction '" << qasm(iname, operands, breg_operands)
                    << "' requires 0 or 1 bit operands, not " << breg_operands.size()
                );
            }

            // store operands
            if (settings.getReadoutMode(iname)=="feedback") {
                bi.isMeasFeedback = true;
                bi.operands = operands;
                //bi.creg_operands = creg_operands;    // NB: will be empty because of checks performed earlier
                bi.breg_operands = breg_operands;
            }
        }

        // store 'expression' for conditional gates
        bi.condition = condition;
        bi.cond_operands = cond_operands;
#endif

        QL_DOUT("customGate(): iname='" << iname <<
             "', duration=" << durationInCycles <<
             " [cycles], instrIdx=" << csv.si.instrIdx <<
             ", group=" << csv.si.group);

        // NB: code is generated in bundleFinish()
    }   // for(signal)

#if OPT_PRAGMA
    RawPtr<const Json> pragma = settings.getPragma(iname);
    if (pragma) {
        for (Vec<BundleInfo> &vbi : bundleInfo) {
            // FIXME: for now we just store the JSON of the pragma statement in bundleInfo[*][0]
            if(vbi[0].pragma) {
                QL_INPUT_ERROR("Bundle contains more than one gate with 'pragma' key");    // FIXME: provide context
            }
            vbi[0].pragma = pragma;

            // store operands
            vbi[0].operands = operands;
            //vbi[0].creg_operands = creg_operands;    // NB: will be empty because of checks performed earlier
            vbi[0].breg_operands = breg_operands;
        }
    }
#endif
}


typedef struct {
    utils::Vec<utils::UInt> cond_operands;
    ConditionType cond_type;
} tInstructionCondition;

/**
 * Decode the expression for a conditional instruction into the old format as used for the API. Eventually this will have
 * to be changed, but as long as the CC can handle expressions with 2 variables only this covers all we need.
 */
tInstructionCondition decode_condition(const OperandContext &operandContext, const ir::ExpressionRef &condition) {
    utils::Vec<utils::UInt> cond_operands;
    ConditionType cond_type;
    try {
        if (auto blit = condition->as_bit_literal()) {
            if (blit->value) {
                cond_type = ConditionType::ALWAYS;
            } else {
                cond_type = ConditionType::NEVER;
            }
        } else if (condition->as_reference()) {
            cond_operands.push_back(operandContext.convert_breg_reference(condition));
            cond_type = ConditionType::UNARY;
        } else if (auto fn = condition->as_function_call()) {
            if (
                fn->function_type->name == "operator!" ||
                fn->function_type->name == "operator~"
            ) {
                CHECK_COMPAT(fn->operands.size() == 1, "unsupported condition function");
                if (fn->operands[0]->as_reference()) {
                    cond_operands.push_back(operandContext.convert_breg_reference(fn->operands[0]));
                    cond_type = ConditionType::NOT;
                } else if (auto fn2 = fn->operands[0]->as_function_call()) {
                    CHECK_COMPAT(fn2->operands.size() == 2, "unsupported condition function");
                    cond_operands.push_back(operandContext.convert_breg_reference(fn2->operands[0]));
                    cond_operands.push_back(operandContext.convert_breg_reference(fn2->operands[1]));
                    if (
                        fn2->function_type->name == "operator&" ||
                        fn2->function_type->name == "operator&&"
                    ) {
                        cond_type = ConditionType::NAND;
                    } else if (
                        fn2->function_type->name == "operator|" ||
                        fn2->function_type->name == "operator||"
                    ) {
                        cond_type = ConditionType::NOR;
                    } else if (
                        fn2->function_type->name == "operator^" ||
                        fn2->function_type->name == "operator^^" ||
                        fn2->function_type->name == "operator!="
                    ) {
                        cond_type = ConditionType::NXOR;
                    } else if (
                        fn2->function_type->name == "operator=="
                    ) {
                        cond_type = ConditionType::XOR;
                    } else {
                        QL_ICE("unsupported gate condition");
                    }
                } else {
                    QL_ICE("unsupported gate condition");
                }
            } else {
                CHECK_COMPAT(fn->operands.size() == 2, "unsupported condition function");
                cond_operands.push_back(operandContext.convert_breg_reference(fn->operands[0]));
                cond_operands.push_back(operandContext.convert_breg_reference(fn->operands[1]));
                if (
                    fn->function_type->name == "operator&" ||
                    fn->function_type->name == "operator&&"
                ) {
                    cond_type = ConditionType::AND;
                } else if (
                    fn->function_type->name == "operator|" ||
                    fn->function_type->name == "operator||"
                ) {
                    cond_type = ConditionType::OR;
                } else if (
                    fn->function_type->name == "operator^" ||
                    fn->function_type->name == "operator^^" ||
                    fn->function_type->name == "operator!="
                ) {
                    cond_type = ConditionType::XOR;
                } else if (
                    fn->function_type->name == "operator=="
                ) {
                    cond_type = ConditionType::NXOR;
                } else {
                    QL_ICE("unsupported condition function");
                }
            }
        } else {
            QL_ICE("unsupported condition expression");
        }
    } catch (utils::Exception &e) {
        e.add_context("in gate condition", true);
        throw;
    }
    return {cond_operands, cond_type};
}

void Codegen::custom_instruction(const ir::CustomInstruction &custom) {
        // Handle the condition. NB: the 'condition' field exists for all conditional_instruction sub types,
        // but we only handle it for custom_instruction
        tInstructionCondition instrCond = decode_condition(operandContext, custom.condition);

        Operands ops;

        // Handle the template operands for the instruction_type we got. Note that these are empty if that is a 'root'
        // InstructionType, and only contains data if it is one of the specializations (see ir.gen.h)

// FIXME: these are operands that match a specialized instruction definition, e.g. "cz q0,q10"
// FIXME: these are not handled below, so things fail if we have such definitions
//cQASM "cz q[0],q[10]" with JSON "cz q0,q10" results in:
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/backend.cc:152 custom instruction: name=cz
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:814 found template_operands: JSON = {"cc":{"signal":[],"static_codeword_override":[0]},"duration":40}
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:798 template operand: q[0]
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:798 template operand: q[10]
//
//cQASM "cz q[0],q[10]" with JSON "cz q0,q9" results in:
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/backend.cc:152 custom instruction: name=cz
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:814 found template_operands: JSON = {"cc":{"signal":[],"static_codeword_override":[0]},"duration":40}
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:798 template operand: q[0]
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:809 operand: q[10]
//
//cQASM "cz q[0],q[10]" with JSON "cz q1,q10" results in:
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/backend.cc:152 custom instruction: name=cz
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:829 operand: q[0]
//[OPENQL] /Volumes/Data/shared/GIT/OpenQL/src/ql/arch/cc/pass/gen/vq1asm/detail/codegen.cc:829 operand: q[10]

        // FIXME: check for existing decompositions (which should have been performed already by an upstream pass)

        if(!custom.instruction_type->template_operands.empty()) {
            QL_DOUT("found template_operands: JSON = " << custom.instruction_type->data.data );
            QL_INPUT_ERROR("CC backend cannot yet handle specialized instructions");
        }

        for (const auto &ob : custom.instruction_type->template_operands) {
            QL_DOUT("template operand: " + ir::describe(ob));
            try {
                ops.append(operandContext, ob);
            } catch (utils::Exception &e) {
                e.add_context("name=" + custom.instruction_type->name + ", qubits=" + ops.qubits.to_string());
                throw;
            }
        }

        // Handle the 'plain' operands for custom instructions.
        for (utils::UInt i = 0; i < custom.operands.size(); i++) {
            QL_DOUT("operand: " + ir::describe(custom.operands[i]));
            try {
                ops.append(operandContext, custom.operands[i]);
            } catch (utils::Exception &e) {
                e.add_context(
                    "name=" + custom.instruction_type->name
                    + ", qubits=" + ops.qubits.to_string()
                    + ", operand=" + std::to_string(i)
                    );
                throw;
            }
        }
#if 0   // org: processes org.has_integer/ops.integer
        kernel->gate(
            custom.instruction_type->name, ops.qubits, ops.cregs,
            0, ops.angle, ops.bregs
        );
        if (ops.has_integer) {
            CHECK_COMPAT(
                kernel->gates.size() == first_gate_index + 1,
                "gate with integer operand cannot be ad-hoc decomposed"
            );
            kernel->gates.back()->int_operand = ops.integer;
        }
#endif

        // FIXME: if we have a cz with operands for which no decomposition exists, we'll end up with:
        // RuntimeError: JSON error: in pass VQ1Asm, phase main: in block 'repeatUntilSuccess': in for loop body: instruction not found: 'cz'
        // This provides little insight, and why do we get upto here anyway? See above: template_operands

        customGate(
            custom.instruction_type->name,
            ops.qubits,     // operands
            ops.cregs,      // creg_operands
            ops.bregs,      // breg_operands
            instrCond.cond_type,      // condition
            instrCond.cond_operands,  // cond_operands
            ops.angle,      // angle
            custom.cycle,    // startCycle
            custom.instruction_type->duration    // durationInCycles
        );

}

/************************************************************************\
| Classical operations on kernels
\************************************************************************/

void Codegen::if_else(const ir::ExpressionRef &condition, const Str &label, Int branch) {
    // finish previous branch
    if (branch>0) {
        emit("", "jmp", as_target(to_end(label)));
    }

    comment(
        "# IF_ELSE: "
        "condition = '" + ir::describe(condition) + "'"
        ", label = '" + label + "'"
    );
    Str my_label = to_ifbranch(label, branch);
    Str jmp_label = to_ifbranch(label, branch+1);
    emit(as_label(my_label), "", "");     // not used if branch==0
    handle_expression(condition, jmp_label, "if.condition");
}


void Codegen::if_otherwise(const Str &label, Int branch) {
    comment(
        "# IF_OTHERWISE: "
        ", label = '" + label + "'"
    );

    Str my_label = to_ifbranch(label, branch);
    emit(as_label(my_label), "", "");
}


void Codegen::if_end(const Str &label) {
    comment(
        "# IF_END: "
        ", label = '" + label + "'"
    );

     emit(as_label(to_end(label)), "", "");
}


void Codegen::foreach_start(const ir::Reference &lhs, const ir::IntLiteral &frm, const Str &label) {
    emit(as_label(to_start(label)), "", "");    // label for looping or 'continue'

#if 0
    handle_set_instruction(*initialize, "for.initialize");

    static_loop->lhs->target;
    static_loop->frm->value;
#endif
}


void Codegen::foreach_end(const ir::IntLiteral &frm, const ir::IntLiteral &to, const Str &label) {
#if 0
    static_loop->frm->value;
    static_loop->to->value;
#endif
    emit("", "jmp", as_target(to_start(label)), "# loop");
    emit(as_label(to_end(label)), "", "");    // label for loop end or 'break'
}


void Codegen::repeat(const Str &label) {
    emit(as_label(to_start(label)), "", "");    // label for looping or 'continue'
}


void Codegen::until(const ir::ExpressionRef &condition, const Str &label) {
    handle_expression(condition, to_end(label), "until.condition");
    emit("", "jmp", as_target(to_start(label)), "# loop");
    emit(as_label(to_end(label)), "", "");    // label for loop end or 'break'
}


void Codegen::for_start(utils::Maybe<ir::SetInstruction> &initialize, const ir::ExpressionRef &condition, const Str &label) {
    comment(
        "# FOR_START: "
        + (!initialize.empty() ? "initialize = '"+ir::describe(initialize)+"', " : "")
        + "condition = '" + ir::describe(condition) + "'"
    );

    // for loop: initialize
    if (!initialize.empty()) {
        handle_set_instruction(*initialize, "for.initialize");
    }

    emit(as_label(to_start(label)), "", "");    // label for looping or 'continue'
    handle_expression(condition, to_end(label), "for.condition");
}

void Codegen::for_end(utils::Maybe<ir::SetInstruction> &update, const Str &label) {
    comment(
        "# FOR_END: "
        + (!update.empty() ? " update = '"+ir::describe(update)+"'" : "")
    );
    // FIXME: use 'loop' instruction if possible
    if (!update.empty()) {
        handle_set_instruction(*update, "for.update");
    }
    emit("", "jmp", as_target(to_start(label)), "# loop");
    emit(as_label(to_end(label)), "", "");    // label for loop end or 'break'
}

void Codegen::do_break(const Str &label) {
    emit("", "jmp", as_target(to_end(label)), "# break");
}

void Codegen::do_continue(const Str &label) {
    emit("", "jmp", as_target(to_start(label)), "# continue");
}


void Codegen::comment(const Str &c) {
    if (options->verbose) emit(c);
}

/************************************************************************\
| new IR expressions
\************************************************************************/

void Codegen::handle_set_instruction(const ir::SetInstruction &set, const Str &descr)
{
    QL_DOUT(descr << ": '" << ir::describe(set) << "'");
    do_handle_expression(set.rhs, set.lhs, "", descr);

}

void Codegen::handle_expression(const ir::ExpressionRef &expression, const Str &label_if_false, const Str &descr)
{
    QL_DOUT(descr << ": '" << ir::describe(expression) << "'");
    do_handle_expression(expression, One<ql::ir::Expression>(), label_if_false, descr);
}


/************************************************************************\
|
| private functions
|
\************************************************************************/

/************************************************************************\
| Some helpers to ease nice assembly formatting
\************************************************************************/

// FIXME: assure space between fields!
// FIXME: make comment output depend on verboseCode

void Codegen::emit(const Str &labelOrComment, const Str &instr) {
    if (labelOrComment.empty()) {                       // no label
        codeSection << "        " << instr << std::endl;
    } else if (labelOrComment.length() < 8) {           // label fits before instr
        codeSection << std::setw(8) << labelOrComment << instr << std::endl;
    } else if (instr.empty()) {                         // no instr
        codeSection << labelOrComment << std::endl;
    } else {
        codeSection << labelOrComment << std::endl << "        " << instr << std::endl;
    }
}


// @param   labelOrSel      label must include trailing ":"
// @param   comment         must include leading "#"
void Codegen::emit(const Str &labelOrSel, const Str &instr, const Str &ops, const Str &comment) {
    codeSection << std::setw(16) << labelOrSel << std::setw(16) << instr << std::setw(36) << ops << comment << std::endl;
}

void Codegen::emit(Int slot, const Str &instr, const Str &ops, const Str &comment) {
    emit(QL_SS2S("[" << slot << "]"), instr, ops, comment);
}

/************************************************************************\
| helpers
\************************************************************************/

void Codegen::showCodeSoFar() {
    // provide context to help finding reason. FIXME: limit # lines
    QL_EOUT("Code so far:\n" << codeSection.str());
}

void Codegen::emitProgramStart(const Str &progName) {
    // emit program header
    codeSection << std::left;    // assumed by emit()
    codeSection << "# Program: '" << progName << "'" << std::endl;   // NB: put on top so it shows up in internal CC logging
    codeSection << "# CC_BACKEND_VERSION " << CC_BACKEND_VERSION_STRING << std::endl;
    codeSection << "# OPENQL_VERSION " << OPENQL_VERSION_STRING << std::endl;
    codeSection << "# Note:    generated by OpenQL Central Controller backend" << std::endl;
    codeSection << "#" << std::endl;

#if OPT_FEEDBACK
    emit(".CODE");   // start .CODE section
#endif

    // NB: new seq_bar semantics (firmware from 20191219 onwards)
    comment("# synchronous start and latency compensation");
    emit("",                "seq_bar",  "",                 "# synchronization, delay set externally through SET_SEQ_BAR_CNT");
    emit("",                "seq_out",  "0x00000000,1",     "# allows monitoring actual start time using trace unit");
    if (!options->run_once) {
        comment("# start of main loop that runs indefinitely");
        emit("__mainLoop:",     "",         "",                 "# ");    // FIXME: __mainLoop should be a forbidden kernel name
    }
#if OPT_FEEDBACK
    // initialize state
    emit("",                "seq_state","0",                "# clear Programmable Logic state");
#endif
}


void Codegen::emitProgramFinish() {
    comment("# finish program");
    if (options->run_once) {   // program runs once only
        emit("", "stop");
    } else {   // CC-light emulation: loop indefinitely
        // prevent real time pipeline emptying during jmp below (especially in conjunction with pragma/break
        emit("", "seq_wait", "1", "");

        // loop indefinitely
        emit("",      // no CCIO selector
             "jmp",
             "@__mainLoop",
             "# loop indefinitely");
    }

    emit(".END");   // end .CODE section
}


// generate code to input measurement results and distribute them via DSM
void Codegen::emitFeedback(
    const FeedbackMap &feedbackMap,
    UInt instrIdx,
    UInt startCycle,
    Int slot,
    const Str &instrumentName
) {
    if (startCycle > lastEndCycle[instrIdx]) {  // i.e. if(!instrHasOutput)
        emitPadToCycle(instrIdx, startCycle, slot, instrumentName);
    }

    // code generation for participating and non-participating instruments (NB: must take equal number of sequencer cycles)
    if (!feedbackMap.empty()) {    // this instrument performs readout for feedback now
        UInt mux = dp.getOrAssignMux(instrIdx, feedbackMap);
        dp.emitMux(mux, feedbackMap, instrIdx, slot);

        // emit code for slot input
        UInt sizeTag = Datapath::getSizeTag(feedbackMap.size());        // compute DSM transfer size tag (for 'seq_in_sm' instruction)
        UInt smAddr = Datapath::getMuxSmAddr(feedbackMap);
        emit(
            slot,
            "seq_in_sm",
            QL_SS2S("S" << smAddr << ","  << mux << "," << sizeTag),
            QL_SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << lastEndCycle[instrIdx]+1 << ": feedback on '" << instrumentName+"'")
        );
        lastEndCycle[instrIdx]++;
    } else {    // this instrument does not perform readout for feedback now
        // emit code for non-participating instrument
        // FIXME: may invalidate DSM that ust arrived dependent on individual SEQBAR counts
        UInt smAddr = 0;
        UInt smTotalSize = 1;    // FIXME: inexact, but me must not invalidate memory that we will not write
        emit(
            slot,
            "seq_inv_sm",
            QL_SS2S("S" << smAddr << ","  << smTotalSize),
            QL_SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << lastEndCycle[instrIdx]+1 << ": invalidate SM on '" << instrumentName+"'")
        );
        lastEndCycle[instrIdx]++;
    }
}


void Codegen::emitOutput(
        const CondGateMap &condGateMap,
        tDigital digOut,
        UInt instrMaxDurationInCycles,
        UInt instrIdx,
        UInt startCycle,
        Int slot,
        const Str &instrumentName
) {
    comment(QL_SS2S(
        "  # slot=" << slot
        << ", instrument='" << instrumentName << "'"
        << ": lastEndCycle=" << lastEndCycle[instrIdx]
        << ", startCycle=" << startCycle
        << ", instrMaxDurationInCycles=" << instrMaxDurationInCycles
    ));

    emitPadToCycle(instrIdx, startCycle, slot, instrumentName);

    // emit code for slot output
    if (condGateMap.empty()) {    // all groups unconditional
        emit(
            slot,
            "seq_out",
            QL_SS2S("0x" << std::hex << std::setfill('0') << std::setw(8) << digOut << std::dec << "," << instrMaxDurationInCycles),
            QL_SS2S("# cycle " << startCycle << "-" << startCycle + instrMaxDurationInCycles << ": code word/mask on '" << instrumentName + "'")
        );
    } else {    // at least one group conditional
        // configure datapath PL
        UInt pl = dp.getOrAssignPl(instrIdx, condGateMap);
        UInt smAddr = dp.emitPl(pl, condGateMap, instrIdx, slot);

        // emit code for conditional gate
        emit(
            slot,
            "seq_out_sm",
            QL_SS2S("S" << smAddr << "," << pl << "," << instrMaxDurationInCycles),
            QL_SS2S("# cycle " << startCycle << "-" << startCycle + instrMaxDurationInCycles << ": conditional code word/mask on '" << instrumentName << "'")
        );
    }

    // update lastEndCycle
    lastEndCycle[instrIdx] = startCycle + instrMaxDurationInCycles;
}

#if 0
void Codegen::emitPragma(
    const Json &pragma,
    Int pragmaSmBit,
    UInt instrIdx,
    UInt startCycle,
    Int slot,
    const Str &instrumentName
) {
    if (startCycle > lastEndCycle[instrIdx]) {    // i.e. if(!instrHasOutput)
        emitPadToCycle(instrIdx, startCycle, slot, instrumentName);
    }

    // FIXME: the only pragma possible is "break" for now
    Int pragmaBreakVal = json_get<Int>(pragma, "break", "pragma of unknown instruction");        // FIXME: we don't know which instruction we're dealing with, so better move
    UInt smAddr = pragmaSmBit / 32;    // 'seq_cl_sm' is addressable in 32 bit words
    UInt mask = 1ul << (pragmaSmBit % 32);
    std::string label = pragmaLoopLabel.back() + "_end";        // FIXME: must match label set in forEnd(), assumes we are actually inside a for loop

    // emit code for pragma "break". NB: code is identical for all instruments
    // FIXME: verify that instruction duration matches actual time
/*
    seq_cl_sm   S<address>          ; pass 32 bit SM-data to Q1 ...
    seq_wait    3                   ; prevent starvation of real time part during instructions below: 4 classic instructions + 1 branch
    move_sm     Ra                  ; ... and move to register
    nop                             ; register dependency Ra
    and         Ra,<mask>,Rb        ; mask depends on DSM bit location
    nop                             ; register dependency Rb
    jlt         Rb,1,@loop
*/
    emit(slot, "seq_cl_sm", QL_SS2S("S" << smAddr), QL_SS2S("# 'break if " << pragmaBreakVal << "' on '" << instrumentName << "'"));
    emit(slot, "seq_wait", "3", "");
    emit(slot, "move_sm", REG_TMP0, "");
    emit(slot, "nop", "", "");
    emit(slot, "and", QL_SS2S(REG_TMP0<< "," << mask << "," << REG_TMP1), "");    // results in '0' for 'bit==0' and 'mask' for 'bit==1'
    emit(slot, "nop", "", "");
    if (pragmaBreakVal == 0) {
        emit(slot, "jlt", QL_SS2S(REG_TMP1 << ",1,@" << label), "");
    } else {
        emit(slot, "jge", QL_SS2S(REG_TMP1 << ",1,@" << label), "");
    }
}
#endif


void Codegen::emitPadToCycle(UInt instrIdx, UInt startCycle, Int slot, const Str &instrumentName) {
    // compute prePadding: time to bridge to align timing
    int prePadding = startCycle - lastEndCycle[instrIdx];
    if (prePadding < 0) {
        QL_EOUT("Inconsistency detected in bundle contents: printing code generated so far");
        showCodeSoFar();
        QL_INPUT_ERROR(
            "Inconsistency detected in bundle contents: time travel not yet possible in this version: prePadding=" << prePadding
            << ", startCycle=" << startCycle
            << ", lastEndCycle=" << lastEndCycle[instrIdx]
            << ", instrumentName='" << instrumentName << "'"
            << ", instrIdx=" << instrIdx
        );
    }

    if (prePadding > 0) {     // we need to align
        emit(
            slot,
            "seq_wait",
            QL_SS2S(prePadding),
            QL_SS2S("# cycle " << lastEndCycle[instrIdx] << "-" << startCycle << ": padding on '" << instrumentName+"'")
        );
    }

    // update lastEndCycle
    lastEndCycle[instrIdx] = startCycle;
}


// compute signalValueString, and some meta information, for sd[s] (i.e. one of the signals in the JSON definition of an instruction)
Codegen::CalcSignalValue Codegen::calcSignalValue(
    const Settings::SignalDef &sd,
    UInt s,
    const Vec<UInt> &operands,
    const Str &iname
) {
    CalcSignalValue ret;
    Str signalSPath = QL_SS2S(sd.path<<"["<<s<<"]");                   // for JSON error reporting

    /************************************************************************\
    | get signal properties, mapping operand index to qubit
    \************************************************************************/

    // get the operand index & qubit to work on
    ret.operandIdx = json_get<UInt>(sd.signal[s], "operand_idx", signalSPath);
    if (ret.operandIdx >= operands.size()) {
        QL_JSON_ERROR(
            "instruction '" << iname
            << "': JSON file defines operand_idx " << ret.operandIdx
            << ", but only " << operands.size()
            << " operands were provided (correct JSON, or provide enough operands)"
        ); // FIXME: add offending statement
    }
    UInt qubit = operands[ret.operandIdx];

    // get signal value
    const Json instructionSignalValue = json_get<const Json>(sd.signal[s], "value", signalSPath);   // NB: json_get<const Json&> unavailable
    Str sv = QL_SS2S(instructionSignalValue);   // serialize/stream instructionSignalValue into std::string

    // get instruction signal type (e.g. "mw", "flux", etc)
    // NB: instructionSignalType is different from "instruction/type" provided by find_instruction_type, although some identical strings are used). NB: that key is no longer used by the 'core' of OpenQL
    Str instructionSignalType = json_get<Str>(sd.signal[s], "type", signalSPath);

    /************************************************************************\
    | map signal type for qubit to instrument & group
    \************************************************************************/

    // find signalInfo, i.e. perform the mapping
    ret.si = settings.findSignalInfoForQubit(instructionSignalType, qubit);

    if (instructionSignalValue.empty()) {    // allow empty signal
        ret.signalValueString = "";
    } else {
        // verify signal dimensions
        UInt channelsPergroup = ret.si.ic.controlModeGroupSize;
        UInt size = instructionSignalValue.is_array() ? instructionSignalValue.size() : 1;  // For objects, size() returns number of keys
        if (size != channelsPergroup) {
//            QL_JSON_ERROR(
            QL_WOUT(    // FIXME: we're transitioning on the semantics of signalValue
                "signal dimension mismatch on instruction '" << iname
                << "' : control mode '" << ret.si.ic.refControlMode
                << "' requires " <<  channelsPergroup
                << " signals, but signal '" << signalSPath+"/value"
                << "' provides " << size
                << " (value='" << instructionSignalValue << "')"
            );
        }

        // expand macros
        sv = replace_all(sv, "\"", "");   // get rid of quotes
#if 1   // FIXME: deprecate?
        sv = replace_all(sv, "{gateName}", iname);
        sv = replace_all(sv, "{instrumentName}", ret.si.ic.ii.instrumentName);
        sv = replace_all(sv, "{instrumentGroup}", to_string(ret.si.group));
        // FIXME: allow using all qubits involved (in same signalType?, or refer to signal: qubitOfSignal[n]), e.g. qubit[0], qubit[1], qubit[2]
        sv = replace_all(sv, "{qubit}", to_string(qubit));
#endif
        ret.signalValueString = sv;

        // FIXME: note that the actual contents of the signalValue only become important when we'll do automatic codeword assignment and provide codewordTable to downstream software to assign waveforms to the codewords
    }

    comment(QL_SS2S(
        "  # slot=" << ret.si.ic.ii.slot
        << ", instrument='" << ret.si.ic.ii.instrumentName << "'"
        << ", group=" << ret.si.group
        << "': signalValue='" << ret.signalValueString << "'"
    ));

    return ret;
}


#if !OPT_SUPPORT_STATIC_CODEWORDS
Codeword codegen_cc::assignCodeword(const Str &instrumentName, Int instrIdx, Int group) {
    Codeword codeword;
    Str signalValue = bi->signalValue;

    if (QL_JSON_EXISTS(codewordTable, instrumentName) &&                        // instrument exists
                    codewordTable[instrumentName].size() > group) {         // group exists
        Bool cwFound = false;
        // try to find signalValue
        Json &myCodewordArray = codewordTable[instrumentName][group];
        for (codeword = 0; codeword < myCodewordArray.size() && !cwFound; codeword++) {   // NB: JSON find() doesn't work for arrays
            if (myCodewordArray[codeword] == signalValue) {
                QL_DOUT("signal value found at cw=" << codeword);
                cwFound = true;
            }
        }
        if (!cwFound) {
            Str msg = QL_SS2S("signal value '" << signalValue
                    << "' not found in group " << group
                    << ", which contains " << myCodewordArray);
            if (mapPreloaded) {
                QL_USER_ERROR("mismatch between preloaded 'backend_cc_map_input_file' and program requirements:" << msg)
            } else {
                QL_DOUT(msg);
                // NB: codeword already contains last used value + 1
                // FIXME: check that number is available
                myCodewordArray[codeword] = signalValue;                    // NB: structure created on demand
            }
        }
    } else {    // new instrument or group
        if (mapPreloaded) {
            QL_USER_ERROR("mismatch between preloaded 'backend_cc_map_input_file' and program requirements: instrument '"
                  << instrumentName << "', group "
                  << group
                  << " not present in file");
        } else {
            codeword = 1;
            codewordTable[instrumentName][group][0] = "";                   // code word 0 is empty
            codewordTable[instrumentName][group][codeword] = signalValue;   // NB: structure created on demand
        }
    }
    return codeword;
}
#endif

/************************************************************************\
| expression helpers
\************************************************************************/

// FIXME: recursion?
// FIXME: or pass SetInstruction or Expression depending on use
// FIXME: adopt structure of cQASM's cqasm-v1-functions-gen.cpp register_into used for constant propagation

/* Actually perform the code generation for an expression. Can be called to handle:
 * - the RHS of a SetInstruction, in which case parameter 'lhs' must be valid
 * - an Expression that acts as a condition for structured control, in which case parameter 'label_if_false' must contain
 * the label to jump to if the expression evaluates as false
 * The distinction between the two modes of operation is made based on the type of expression, either 'bit' or 'int',
 * which is possible because of the rather strict separation between these two types.
 *
 *
 * To understand how cQASM functions end up in the IR, please note that functions are handled during analyzing cQASM,
 * see 'AnalyzerHelper::analyze_function()'.
 *
 * A default set of functions that only handle constant arguments is provided by libqasm, see
 * 'register_into(resolver::FunctionTable &table)'. These functions add a constant node to the IR when called (and fail
 * if the arguments are not constant)
 *
 * Some of these are overridden by OpenQL to allow use of non-constant arguments. This is a 2 step process, where
 * 'convert_old_to_new(const compat::PlatformRef &old)' adds functions to the platform using 'add_function_type',
 * and 'ql::ir::cqasm:read()' then walks 'ir->platform->functions' and adds the functions using 'register_function()'.
 * These functions add a 'cqv::Function' node to the IR (even if the arguments are constant).
 */
void Codegen::do_handle_expression(
    const ir::ExpressionRef &expression,
    const ir::ExpressionRef &lhs,
    const Str &label_if_false,
    const Str &descr
) {
    // function global helpers
    auto creg2reg = [this](const ir::ExpressionRef &ref) {
        auto reg = operandContext.convert_creg_reference(ref);
        if(reg >= NUM_CREGS) {
            QL_INPUT_ERROR("register index " << reg << " exceeds maximum");
        }
        return reg;
    };
    auto breg2reg = [this](const ir::ExpressionRef &ref) {    // FIXME: makes no sense, and needs to go through DSM bit allocator
        auto reg = operandContext.convert_breg_reference(ref);
//        if(reg >= NUM_CREGS) {
//            QL_INPUT_ERROR("register index " << reg << " exceeds maximum");
//        }
        return reg;
    };
    auto dest_reg = [creg2reg, lhs]() { return creg2reg(lhs); };

    // Convert integer/creg function_call.operands expression to Q1 instruction argument.
    auto op_str_int = [creg2reg](const ir::ExpressionRef &op) {
        if(op->as_reference()) {
            return QL_SS2S("R" << creg2reg(op));
        } else if(op->as_int_literal()) {
            return QL_SS2S(op->as_int_literal()->value);
        } else {
            QL_ICE("Expected integer operand");
        }
    };

    // Convert bit/breg function_call.operands expression to FIXME: return type makes no sense
    auto op_str_bit = [breg2reg](const ir::ExpressionRef &op) {   // FIXME: misnomer op_str_bit
        if(op->as_reference()) {
            return breg2reg(op);
        } else if(op->as_int_literal()) {   // FIXME: do literals make sense here
            return op->as_int_literal()->value;
        } else {
            QL_ICE("Expected bit operand");
        }
    };

    auto emit_bin_cast = [this, op_str_bit](Any<ir::Expression> operands) {
//    auto emit_bin_cast = [this, op_str_bit](Vec<Int> operands) {
        // FIXME: based on emitPragma, cleanup
        // FIXME: CHECK_COMPAT
        auto num_ops = operands.size();
        UInt smBit = op_str_bit(operands[0]);   // FIXME: lookup allocation
        auto arg0 = op_str_bit(operands[0]);
        auto arg1 = op_str_bit(operands[1]);

//                Int pragmaBreakVal = json_get<Int>(pragma, "break", "pragma of unknown instruction");        // FIXME: we don't know which instruction we're dealing with, so better move
        UInt smAddr = smBit / 32;    // 'seq_cl_sm' is addressable in 32 bit words
        UInt mask = 1ul << (smBit % 32);
//                std::string label = pragmaLoopLabel.back() + "_end";        // FIXME: must match label set in forEnd(), assumes we are actually inside a for loop

        // emit code for pragma "break". NB: code is identical for all instruments
        // FIXME: verify that instruction duration matches actual time
        /*
            seq_cl_sm   S<address>          ; pass 32 bit SM-data to Q1 ...
            seq_wait    3                   ; prevent starvation of real time part during instructions below: 4 classic instructions + 1 branch
            move_sm     Ra                  ; ... and move to register
            nop                             ; register dependency R0
            and         Ra,<mask>,Rb        ; mask depends on DSM bit location
            nop                             ; register dependency R1
            jlt         Rb,1,@loop
        */
        emit("", "seq_cl_sm", QL_SS2S("S" << smAddr), "");
        emit("", "seq_wait", "3", "");
        emit("", "move_sm", REG_TMP0, "");
        emit("", "nop", "", "");
        emit("", "and", QL_SS2S(REG_TMP0 << "," << mask << "," << REG_TMP1), "");    // results in '0' for 'bit==0' and 'mask' for 'bit==1'
        emit("", "nop", "", "");
#if 0
        if (pragmaBreakVal == 0) {
            emit("", "jlt", QL_SS2S(REG_TMP1 << ",1,@" << label), "");
        } else {
            emit("", "jge", QL_SS2S(REG_TMP1 << ",1,@" << label), "");
        }
#endif
    };
    // ----------- end of global helpers -------------

    try {
        // FIXME: emit lhs+expression as comment (only here)

        if (auto ilit = expression->as_int_literal()) {
            emit(
                "",
                "move",
                QL_SS2S(ilit->value << ",R" << dest_reg())
                , "# " + ir::describe(expression)
            );
        // FIXME expression->as_bit_literal()
        } else if (expression->as_reference()) {
            if(operandContext.is_creg_reference(expression)) {
                auto reg = creg2reg(expression);
                emit(
                    "",
                    "move",
                    QL_SS2S("R" << reg << ",R" << dest_reg())  // FIXME: use op_str_int?
                    , "# " + ir::describe(expression)
                );
            } else {
                auto breg = operandContext.convert_breg_reference(expression);
                comment(QL_SS2S("# FIXME: cast " << ir::describe(expression)));
//                emit_bin_cast(expression);
                // FIXME: move to lhs
            }
        } else if (auto fn = expression->as_function_call()) {
            // function call helpers
            enum Profile {
                LR,     // int Literal, Reference
                RL,
                RR
            };
            auto get_profile = [](Any<ir::Expression> operands) {
                CHECK_COMPAT(
                    operands.size() == 2,
                    "expected 2 operands"
                );
                if(operands[0]->as_int_literal() && operands[1]->as_reference()) {
                    return LR;
                } else if(operands[0]->as_reference() && operands[1]->as_int_literal()) {
                    return RL;
                } else if(operands[0]->as_reference() && operands[1]->as_reference()) {
                    return RR;
                } else if(operands[0]->as_int_literal() && operands[1]->as_int_literal()) {
                    QL_INPUT_ERROR("cannot currently handle functions on two literal paremeters");
                } else if(operands[0]->as_function_call()) {
                    QL_INPUT_ERROR("cannot handle function call within function call '" << ir::describe(operands[0]) << "'");
                    // FIXME: etc, also handle "creg(0)=creg(0)+1+1" or "1 < i+3"
                } else if(operands[1]->as_function_call()) {
                    QL_INPUT_ERROR("cannot handle function call within function call '" << ir::describe(operands[1]) << "'");
                } else {
                    QL_INPUT_ERROR("cannot handle parameter combination '" << ir::describe(operands[0]) << "' , '" << ir::describe(operands[1]) << "'");
                    // NB: includes both parameters being int_literal, which we may handle in the future by a separate pass
                }
            };
            auto emit_mnem2args = [this, op_str_int, fn, expression](const Str &mnem, Int arg0, Int arg1, const Str &target=REG_TMP0) {
                emit(
                    "",
                    mnem,
                    QL_SS2S(
                        op_str_int(fn->operands[arg0])
                        << "," << op_str_int(fn->operands[arg1])
                        << "," << target
                    )
                    , "# " + ir::describe(expression)
                );
            };
            // ----------- end of function call helpers -------------

            utils::Str operation;

            // handle cast
            if (fn->function_type->name == "int") {
                CHECK_COMPAT(
                    fn->operands.size() == 1 &&
                    fn->operands[0]->as_function_call(),
                    "'int()' cast target must be a function"
                );
                fn = fn->operands[0]->as_function_call();   // FIXME: step into. Shouldn't we recurse to allow e.g. casting a breg??
            }

            // int arithmetic, 1 operand
            if (fn->function_type->name == "operator~") {
                operation = "not";
                emit(
                    "",
                    operation,
                    QL_SS2S(
                        op_str_int(fn->operands[0])
                        << ",R" << dest_reg()
                    )
                    , "# " + ir::describe(expression)
                );
            }

            // bit arithmetic, 1 operand
            if (fn->function_type->name == "operator!") {
                operation = "not";
                //CHECK_COMPAT
                emit_bin_cast(fn->operands);
                // FIXME: do something
            }

            // int arithmetic, 2 operands
            if (operation.empty()) {    // check group only if nothing found yet
                if (fn->function_type->name == "operator+") {
                    operation = "add";
                } else if (fn->function_type->name == "operator-") {
                    operation = "sub";
                } else if (fn->function_type->name == "operator&") {
                    operation = "and";
                } else if (fn->function_type->name == "operator|") {
                    operation = "or";
                } else if (fn->function_type->name == "operator^") {
                    operation = "xor";
                }
                if (!operation.empty()) {
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_mnem2args(operation, 0, 1); break;
                        case LR:    emit_mnem2args(operation, 1, 0); break;   // reverse operands to match Q1 instruction set
                            if (operation == "sub") {
                                // FIXME: correct for changed op order
                            }
                    }
                }
            }

            // bool/bit arithmetic, 2 operands
            if(operation.empty()) {
                if (fn->function_type->name == "operator&&") {
                    operation = "FIXME";
                } else if (fn->function_type->name == "operator||") {
                    operation = "FIXME";
                } else if (fn->function_type->name == "operator^^") {
                    operation = "FIXME";
                }
                if (!operation.empty()) {
                    emit_bin_cast(fn->operands);
                    // FIXME: perform operation
                }
            }

            // relop, group 1
            if(operation.empty()) {
                if (fn->function_type->name == "operator==") {
                    operation = "jge";
                } else if (fn->function_type->name == "operator!=") {
                    operation = "jlt";
                }
                if(!operation.empty()) {
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_mnem2args("xor", 0, 1); break;
                        case LR:    emit_mnem2args("xor", 1, 0); break;   // reverse operands to match Q1 instruction set
                    }
                    emit("", "nop", "", "");    // register dependency
                    emit("", operation, Str(REG_TMP0)+",1,@"+label_if_false, "");
                }
            }

            // relop, group 2
            if(operation.empty()) {
                if (fn->function_type->name == "operator>=") {
                    operation = ">=";   // NB: actual contents unused here
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_mnem2args("jge", 0, 1, as_target(label_if_false)); break;
                        case LR:    emit_mnem2args("jlt", 1, 0, as_target(label_if_false)); break;   // reverse operands (and instruction) to match Q1 instruction set
                    }
                } else if (fn->function_type->name == "operator<") {
                    operation = "<";
                    switch (get_profile(fn->operands)) {
                        case RL:    // fall through
                        case RR:    emit_mnem2args("jlt", 0, 1, as_target(label_if_false)); break;
                        case LR:    emit_mnem2args("jge", 1, 0, as_target(label_if_false)); break;   // reverse operands (and instruction) to match Q1 instruction set
                    }
                } else if (fn->function_type->name == "operator>") {
                    operation = ">";
                    switch (get_profile(fn->operands)) {
                        case RL:
                            emit(
                                "",
                                "jge",
                                QL_SS2S(
                                    op_str_int(fn->operands[0]) << ","
                                    << fn->operands[1]->as_int_literal()->value + 1    // increment literal since we lack 'jgt'
                                    << ",@"+label_if_false
                                )
                            );
                            break;
                        case RR:
                            emit(
                                "",
                                "add",
                                QL_SS2S(
                                    "1,"
                                    << op_str_int(fn->operands[1])
                                    << "," << REG_TMP0
                                )
                            );                      // increment arg1
                            emit("", "nop", "");    // register dependency
                            emit(
                                "",
                                "jge",
                                QL_SS2S(
                                    op_str_int(fn->operands[0])
                                    << "," << REG_TMP0
                                    << ",@"+label_if_false
                                )
                            );
                            break;
                        case LR:
                            emit(
                                "",
                                "jlt",                              // reverse instruction
                                QL_SS2S(
                                    op_str_int(fn->operands[1])     // reverse operands
                                    << fn->operands[0]->as_int_literal()->value - 1    // DECrement literal since we lack 'jle'
                                    << ",@"+label_if_false
                                )
                            );
                            break;
                    }
                } else if (fn->function_type->name == "operator<=") {
                    operation = "<=";
                    // FIXME
                }
                if(!operation.empty()) {
                    // NB: all work already done above
                }
            }

            if(operation.empty()) {
                // NB: if we arrive here, there's an inconsistency between the functions registered in
                // 'ql::ir::cqasm:read()' (see comment at beginning of this function) and our decoding here.
                QL_ICE(
                    "function '" << fn->function_type->name << "' not supported by CC backend, but it should be"
                );
            }
        }
    }
    catch (utils::Exception &e) {
        e.add_context("in expression '" + ir::describe(expression) + "'", true);
        throw;
    }

}


} // namespace detail
} // namespace vq1asm
} // namespace gen
} // namespace pass
} // namespace cc
} // namespace arch
} // namespace ql
