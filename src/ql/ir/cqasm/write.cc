/** \file
 * cQASM 1.2 writer logic as human-readable complement of the IR.
 */

#include "ql/ir/cqasm/write.h"

#include "ql/version.h"

namespace ql {
namespace ir {
namespace cqasm {

/**
 * cQASM 1.2 writer implemented (more or less) using the visitor pattern.
 */
class Writer : public Visitor<void> {

    /**
     * The stream that we're writing to.
     */
    std::ostream &os;

    /**
     * Line prefix.
     */
    utils::Str line_prefix;

    /**
     * The current indentation level.
     */
    utils::Int indent = 0;

    /**
     * Starts a Line, after updating the indentation level by adding
     * `indent_delta` to it.
     */
    std::string sl(utils::Int indent_delta = 0) {
        std::stringstream ss;
        indent += indent_delta;
        auto indent_remain = indent;
        while (indent_remain-- > 0) {
            ss << "    ";
        }
        return ss.str();
    }

    /**
     * Ends a Line, leaving `blank` blank lines and updating the indentation
     * level by adding `indent_delta` to it.
     */
    std::string el(utils::UInt blank = 0, utils::Int indent_delta = 0) {
        std::stringstream ss;
        indent += indent_delta;
        do {
            ss << "\n" << line_prefix;
        } while (blank--);
        return ss.str();
    }

    /**
     * The set of all names currently in use or reserved.
     */
    utils::Set<utils::Str> names;

    /**
     * Map from tree node to uniquified name.
     */
    utils::Map<const void*, utils::Str> unique_names;

    /**
     * Generates a unique, valid identifier for the given node based on the
     * given desired name. Calling this multiple times for the same non-empty
     * node is guaranteed to return the same identifier. Calling this multiple
     * times for empty nodes will yield unique identifiers.
     */
    utils::Str uniquify(
        const utils::One<Node> &node,
        const utils::Str &desired_name
    ) {

        // See if we've uniquified the name for this node before.
        const void *key = node.get_ptr().get();
        if (key != nullptr) {
            auto it = unique_names.find(key);
            if (it != unique_names.end()) {
                return it->second;
            }
        }

        // Make a unique, valid identifier based on the desired name.
        auto name = std::regex_replace(desired_name, std::regex("[^a-zA-Z0-9_]"), "_");
        if (!std::regex_match(name, IDENTIFIER_RE)) name = "_" + name;
        auto unique_name = name;
        utils::UInt unique_idx = 1;
        while (!names.insert(unique_name).second) {
            unique_name = name + "_" + utils::to_string(unique_idx++);
        }
        QL_ASSERT(std::regex_match(unique_name, IDENTIFIER_RE));

        // Store the uniquified name in the map.
        if (key != nullptr) {
            unique_names.insert({key, unique_name});
        }

        return unique_name;
    }

    /**
     * Generates a unique, valid identifier.
     */
    utils::Str uniquify(const utils::Str &desired_name) {
        return uniquify({}, desired_name);
    }

    /**
     * Reference to the platform.
     */
    PlatformRef platform;

public:

    /**
     * Constructs a writer for the given stream.
     */
    Writer(
        std::ostream &os = std::cout,
        const utils::Str &line_prefix = ""
    ) :
        os(os),
        line_prefix(line_prefix),
        names({

            // cQASM 1.2 keywords:
            "break", "cond", "continue", "else", "for", "foreach", "if",
            "map", "repeat", "set", "qubits", "until", "var", "while",

            // Default mappings that we probably shouldn't touch:
            "q", "b", "pi", "eu", "im", "true", "false",

            // Maybe don't auto-generate an identifier that is just an
            // underscore.
            "_"

        })
    {}

    /**
     * Fallback function.
     */
    void visit_node(Node &node) override {
        node.dump(std::cerr);
        throw utils::Exception(
            "unexpected node type encountered while writing cQASM"
        );
    }

    /**
     * Visitor function for `Root` nodes.
     */
    void visit_root(Root &node) override {
        platform = node.platform;

        // Write initial line prefix (if any).
        os << line_prefix;

        // Generate header.
        os << sl() << "# Generated by OpenQL " << OPENQL_VERSION_STRING;
        os << " for program " << node.program->name << el();
        os << sl() << "version 1.2" << el(1);

        // Add a pragma with the program name.
        os << sl() << "pragma @ql.name(\"" << node.program->name << "\")" << el(1);

        node.platform->visit(*this);
        node.program->visit(*this);
    }

    /**
     * Visitor function for `Platform` nodes.
     */
    void visit_platform(Platform &node) override {

        // Reserve names for the builtin instructions, functions, and objects
        // described in the platform.
        for (const auto &insn : node.instructions) {
            names.insert(insn->cqasm_name);
        }
        for (const auto &func : node.functions) {
            names.insert(func->name);
        }
        for (const auto &obj : node.objects) {
            if (obj->shape.empty()) {
                names.insert(obj->name);
            } else if (obj->shape.size() > 1) {
                throw utils::Exception("multidimensional objects are not supported");
            } else {
                for (utils::UInt i = 0; i < obj->shape[0]; i++) {
                    names.insert(obj->name + utils::to_string(i));
                }
            }
        }

        // Add a pragma with the platform JSON data.
        auto s = node.data->dump(2);
        QL_ASSERT(utils::starts_with(s, "{"));
        QL_ASSERT(utils::ends_with(s, "}"));
        s = std::regex_replace(s.substr(1, s.size() - 2), std::regex("\n"), "\n" + line_prefix);
        os << sl() << "pragma @ql.platform({|" << s.substr() << "|})" << el(1);

    }

    /**
     * Visitor function for `Program` nodes.
     */
    void visit_program(Program &node) override {

        // Dump variables.
        if (!node.objects.empty()) {
            for (const auto &obj : node.objects) {
                try {

                    // cQASM 1.2 doesn't support non-scalar stuff yet.
                    if (!obj->shape.empty()) {
                        throw utils::Exception(
                            "non-scalar variables not supported"
                        );
                    }

                    // Write the variable name.
                    auto name = uniquify(obj, obj->name);
                    os << sl() << "var " << name << ": ";

                    // Write the type.
                    if (obj->data_type->as_qubit_type()) {
                        os << "qubit";
                    } else if (obj->data_type->as_bit_type()) {
                        os << "bit";
                    } else if (obj->data_type->as_int_type()) {
                        os << "int";
                    } else if (obj->data_type->as_real_type()) {
                        os << "real";
                    } else if (obj->data_type->as_complex_type()) {
                        os << "complex";
                    } else if (obj->data_type->as_real_matrix_type()) {
                        throw utils::Exception(
                            "data type " + obj->data_type->name +
                            " not supported for variables"
                        );
                    }

                    // Annotate with the platform type name.
                    if (
                        obj->data_type != platform->default_bit_type &&
                        obj->data_type != platform->default_int_type &&
                        obj->data_type != platform->qubits->data_type
                    ) {
                        os << " @ql.type(\"" << obj->data_type->name << "\")";
                    }

                    // Annotate the object type/name if necessary.
                    if (obj->as_temporary_object()) {
                        os << " @ql.temp()";
                    } else if (name != obj->name) {
                        os << " @ql.name(\"" << obj->name << "\")";
                    }

                    os << el();

                } catch (utils::Exception &e) {
                    if (!obj->name.empty()) {
                        e.messages.push_front("while writing variable " + obj->name);
                    }
                    throw;
                }

            }
        }

        // Handle subcircuit header indentation.
        indent++;

        // If the first block is not the entry point, write a goto instruction
        // in a special entry point subcircuit.
        if (!node.entry_point.links_to(node.blocks[0])) {
            os << el() << sl(-1) << "." << uniquify("entry");
            os << " @ql.entry()" << el(0, 1);
            os << sl() << "goto " << uniquify(node.entry_point.as_mut(), node.entry_point->name) << el();
        }

        // Print the blocks.
        utils::Str exit_name;
        for (utils::UInt idx = 0; idx < node.blocks.size(); idx++) {
            const auto &block = node.blocks[idx];

            // Write the block header.
            auto name = uniquify(block, block->name);
            os << el() << sl(-1) << "." << name;
            if (name != block->name) {
                os << " @ql.name(\"" << block->name << "\")";
            }
            os << el(0, 1);

            // Write the statements.
            block->visit(*this);

            // Write the goto statement for the next block if needed.
            if (block->next.empty() && idx != node.blocks.size() - 1) {
                if (exit_name.empty()) {
                    exit_name = uniquify("exit");
                }
                os << sl() << "goto " << exit_name << el();
            } else {
                utils::Link<Block> seq_next;
                if (idx < node.blocks.size() - 1) {
                    seq_next = node.blocks[idx + 1];
                }
                if (block->next != seq_next) {
                    os << sl() << "goto " << uniquify(block->next.as_mut(), block->next->name) << el();
                }
            }

        }

        // Print the exit label if needed.
        if (!exit_name.empty()) {
            os << el() << sl(-1) << "." << exit_name;
            os << " @ql.exit()" << el();
        }

    }

    /**
     * Prints a bundle of simultaneously-issued (w.r.t. the quantum time domain)
     * instructions.
     */
    void flush_bundle(utils::Any<Instruction> &bundle, utils::UInt cycle) {
        if (bundle.size() == 1) {
            bundle[0]->visit(*this);
        } else if (!bundle.empty()) {
            os << sl() << "{ # start at cycle " << cycle << el(0, 1);
            for (const auto &pending_stmt : bundle) {
                pending_stmt->visit(*this);
            }
            os << sl(-1) << "}" << el();
        }
        bundle.reset();
    }

    /**
     * Visitor function for `BlockBase` nodes.
     */
    void visit_block_base(BlockBase &node) override {

        // Gather bundles before printing them, so we can format them a bit more
        // nicely.
        utils::UInt cycle = 0;
        utils::Any<Instruction> bundle;

        // Loop over all the statements.
        for (const auto &stmt : node.statements) {
            auto insn = stmt.as<Instruction>();

            // If stmt/insn cannot be added to the current bundle because it's
            // scheduled in a different cycle or isn't a schedulable
            // instruction, flush it.
            if (insn.empty() || insn->cycle != cycle) {
                flush_bundle(bundle, cycle);
                if (!insn.empty()) {

                    // Add a skip before the next bundle if necessary.
                    if (insn->cycle > cycle + 1) {
                        os << sl() << "skip " << (insn->cycle - cycle - 1) << el();
                    }

                    cycle = insn->cycle;
                }
            }

            // Now insn (if stmt is an instruction) can be added to the bundle.
            if (!insn.empty()) {
                bundle.add(insn);
                continue;
            }

            // Print statements outside of bundles.
            stmt->visit(*this);

        }

        // Print any remaining bundles.
        flush_bundle(bundle, cycle);

    }

    /**
     * Visitor function for `ConditionalInstruction` nodes.
     */
    void visit_conditional_instruction(ConditionalInstruction &node) override {

        // Don't print condition prefix if this is a trivial condition.
        auto blit = node.condition->as_bit_literal();
        if (blit && blit->value) return;

        // Print the condition.
        os << "cond (";
        node.condition.visit(*this);
        os << ") ";

    }

    /**
     * Visitor function for `CustomInstruction` nodes.
     */
    void visit_custom_instruction(CustomInstruction &node) override {
        os << sl();
        visit_conditional_instruction(node);
        os << node.instruction_type->cqasm_name;
        auto first = true;
        for (const auto &op : node.instruction_type->template_operands) {
            if (!first) {
                os << ",";
            }
            os << " ";
            op->visit(*this);
            first = false;
        }
        for (const auto &op : node.operands) {
            if (!first) {
                os << ",";
            }
            os << " ";
            op->visit(*this);
            first = false;
        }
        os << el();
    }

    /**
     * Visitor function for `SetInstruction` nodes.
     */
    void visit_set_instruction(SetInstruction &node) override {
        os << sl();
        visit_conditional_instruction(node);
        os << "set ";
        node.lhs->visit(*this);
        os << " = ";
        node.rhs->visit(*this);
        os << el();
    }

    /**
     * Visitor function for `GotoInstruction` nodes.
     */
    void visit_goto_instruction(GotoInstruction &node) override {
        os << sl();
        visit_conditional_instruction(node);
        os << "goto " << uniquify(node.target.as_mut(), node.target->name) << el();
    }

    /**
     * Visitor function for `WaitInstruction` nodes.
     */
    void visit_wait_instruction(WaitInstruction &node) override {
        os << sl();
        auto first = true;
        if (node.duration == 0) {
            os << "barrier";
        } else {
            os << "wait " << node.duration;
            first = false;
        }
        for (const auto &op : node.objects) {
            if (!first) {
                os << ",";
            }
            os << " ";
            op->visit(*this);
            first = false;
        }
        os << el();
    }

    /**
     * Visitor function for `SourceInstruction` nodes.
     */
    void visit_source_instruction(SourceInstruction &node) override {
        os << sl() << "pragma @ql.source()" << el();
    }

    /**
     * Visitor function for `SourceInstruction` nodes.
     */
    void visit_sink_instruction(SinkInstruction &node) override {
        os << sl() << "pragma @ql.sink()" << el();
    }

    /**
     * Visitor function for `IfElse` nodes.
     */
    void visit_if_else(IfElse &node) override {
        os << sl();
        for (utils::UInt idx = 0; idx < node.branches.size(); idx++) {
            os << "if (";
            node.branches[idx]->condition->visit(*this);
            os << ") {" << el(0, 1);
            node.branches[idx]->body->visit(*this);
            os << sl(-1) << "}";
            if (idx < node.branches.size() - 1 || !node.otherwise.empty()) {
                os << " else ";
            }
        }
        if (!node.otherwise.empty()) {
            os << "{" << el(0, 1);
            node.otherwise->visit(*this);
            os << sl(-1) << "}";
        }
        os << el();
    }

    /**
     * Visitor function for `StaticLoop` nodes.
     */
    void visit_static_loop(StaticLoop &node) override {
        os << sl() << "foreach (";
        node.lhs->visit(*this);
        os << " = ";
        node.frm->visit(*this);
        os << "..";
        node.to->visit(*this);
        os << ") {" << el(0, 1);
        node.body->visit(*this);
        os << sl(-1) << "}" << el();
    }

    /**
     * Visitor function for `ForLoop` nodes.
     */
    void visit_for_loop(ForLoop &node) override {
        if (node.initialize.empty() && node.update.empty()) {
            os << sl() << "while (";
            node.condition->visit(*this);
        } else {
            os << sl() << "for (";
            if (!node.initialize.empty()) {
                node.initialize->lhs->visit(*this);
                os << " = ";
                node.initialize->rhs->visit(*this);
            }
            os << "; ";
            node.condition->visit(*this);
            os << "; ";
            if (!node.update.empty()) {
                node.update->lhs->visit(*this);
                os << " = ";
                node.update->rhs->visit(*this);
            }
        }
        os << ") {" << el(0, 1);
        node.body->visit(*this);
        os << sl(-1) << "}" << el();
    }

    /**
     * Visitor function for `RepeatUntilLoop` nodes.
     */
    void visit_repeat_until_loop(RepeatUntilLoop &node) override {
        os << sl() << "repeat {" << el(0, 1);
        node.body->visit(*this);
        os << sl(-1) << "} until (";
        node.condition->visit(*this);
        os << ")" << el();
    }

    /**
     * Visitor function for `BreakStatement` nodes.
     */
    void visit_break_statement(BreakStatement &node) override {
        (void)node;
        os << sl() << "break" << el();
    }

    /**
     * Visitor function for `ContinueStatement` nodes.
     */
    void visit_continue_statement(ContinueStatement &node) override {
        (void)node;
        os << sl() << "break" << el();
    }

    /**
     * Visitor function for `BitLiteral` nodes.
     */
    void visit_bit_literal(BitLiteral &node) override {
        if (node.value) {
            os << "true";
        } else {
            os << "false";
        }
    }

    /**
     * Visitor function for `IntLiteral` nodes.
     */
    void visit_int_literal(IntLiteral &node) override {
        os << node.value;
    }

    /**
     * Prints a real number.
     */
    void print_real(utils::Real r) {

        // Accurately printing floating-point values is hard. Half the JSON
        // library is dedicated to it. So why not abuse it for printing
        // literals?
        utils::Json j{r};
        os << j;

    }

    /**
     * Visitor function for `RealLiteral` nodes.
     */
    void visit_real_literal(RealLiteral &node) override {
        print_real(node.value);
    }

    /**
     * Visitor function for `ComplexLiteral` nodes.
     */
    void visit_complex_literal(ComplexLiteral &node) override {
        os << "(";
        print_real(node.value.real());
        os << "+";
        print_real(node.value.imag());
        os << "*im)";
    }

    /**
     * Visitor function for `RealMatrixLiteral` nodes.
     */
    void visit_real_matrix_literal(RealMatrixLiteral &node) override {
        os << "[";
        for (utils::UInt row = 1; row <= node.value.size_rows(); row++) {
            if (row == 1) {
                os << "; ";
            }
            for (utils::UInt col = 1; col <= node.value.size_rows(); col++) {
                if (col == 1) {
                    os << ", ";
                }
                auto value = node.value.at(row, col);
                print_real(value);
            }
        }
    }

    /**
     * Visitor function for `ComplexMatrixLiteral` nodes.
     */
    void visit_complex_matrix_literal(ComplexMatrixLiteral &node) override {
        os << "[";
        for (utils::UInt row = 1; row <= node.value.size_rows(); row++) {
            if (row == 1) {
                os << "; ";
            }
            for (utils::UInt col = 1; col <= node.value.size_rows(); col++) {
                if (col == 1) {
                    os << ", ";
                }
                auto value = node.value.at(row, col);
                print_real(value.real());
                os << "+";
                print_real(value.imag());
                os << "*im";
            }
        }
    }

    /**
     * Visitor function for `StringLiteral` nodes.
     */
    void visit_string_literal(StringLiteral &node) override {
        os << '"';
        for (auto c : node.value) {
            if (c == '"') {
                os << "\\\"";
            } else if (c == '\n') {
                os << "\\n";
            } else if (c == '\r') {
                os << "\\r";
            } else if (c == '\\') {
                os << "\\\\";
            } else {
                os << c;
            }
        }
        os << '"';
    }

    /**
     * Visitor function for `JsonLiteral` nodes.
     */
    void visit_json_literal(JsonLiteral &node) override {
        auto s = node.value->dump();
        QL_ASSERT(utils::starts_with(s, "{"));
        QL_ASSERT(utils::ends_with(s, "}"));
        os << "{|" << s.substr(1, s.size() - 2) << "|}";
    }

    /**
     * Visitor function for `Reference` nodes.
     */
    void visit_reference(Reference &node) override {

        // Figure out the name and the way to print.
        utils::Str name;
        auto typecast = node.data_type != node.target->data_type;
        if (node.target == platform->qubits) {
            if (node.data_type->as_bit_type()) {
                typecast = false;
                name = "b";
            } else {
                name = "q";
            }
        } else if (node.target->as_physical_object()) {
            name = node.target->name;
        } else {
            name = uniquify(node.target.as_mut(), node.target->name);
        }

        // Print the typecast function if needed.
        if (typecast) {
            os << node.data_type->name << "(";
        }
        os << name;
        if (node.target == platform->qubits) {

            // For the main qubit register (and implicit bit register), index
            // using [].
            if (node.indices.size() != 1) {
                throw utils::Exception("main qubit register must be one-dimensional");
            }
            os << "[";
            node.indices[0]->visit(*this);
            os << "]";

        } else if (node.target->as_physical_object()) {

            // cQASM doesn't natively support indexing for things other than the
            // main qubit register. But we can model the index operation as a
            // "runtime" function call, that can be evaluated into a reference
            // during the reading process.
            if (!node.indices.empty()) {
                os << "(";
                auto first = true;
                for (const auto &index : node.indices) {
                    if (!first) {
                        os << ", ";
                    }
                    index->visit(*this);
                    first = false;
                }
                os << ")";
            }

        } else if (!node.indices.empty()) {

            // For user-defined variables, there's no way to do indexing.
            throw utils::Exception("non-scalar variables not supported");

        }
        if (typecast) {
            os << ")";
        }

    }

    /**
     * Visitor function for `FunctionCall` nodes.
     */
    void visit_function_call(FunctionCall &node) override {
        if (!utils::starts_with(node.function_type->name, "operator")) {
            os << node.function_type->name << "(";
            auto first = true;
            for (const auto &op : node.operands) {
                if (!first) {
                    os << ", ";
                }
                op->visit(*this);
                first = false;
            }
            os << ")";
        } else if (node.operands.size() == 3 && node.function_type->name == "operator?:") {
            os << "(";
            node.operands[0]->visit(*this);
            os << " ? ";
            node.operands[1]->visit(*this);
            os << " : ";
            node.operands[2]->visit(*this);
            os << ")";
        } else if (node.operands.size() == 2) {
            os << "(";
            node.operands[0]->visit(*this);
            os << " " << node.function_type->name.substr(8) << " ";
            node.operands[1]->visit(*this);
            os << ")";
        } else if (node.operands.size() == 1) {
            os << node.function_type->name.substr(8);
            node.operands[0]->visit(*this);
        } else {
            throw utils::Exception(
                "unknown operator type " + node.function_type->name
            );
        }
    }

};

/**
 * Writes a cQASM 1.2 representation of the IR to the given stream with the
 * given line prefix.
 */
void write(const Ref &ir, std::ostream &os, const utils::Str &line_prefix) {
    Writer w{os, line_prefix};
    ir->visit(w);
}

} // namespace cqasm
} // namespace ir
} // namespace ql
