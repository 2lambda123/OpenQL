/**
 * @file   quantumsim_eqasm_compiler.h
 * @date   03/2018
 * @author Imran Ashraf
 * @brief  quantumsim compiler implementation
 */

#ifndef QL_QUANTUMSIM_EQASM_COMPILER_H
#define QL_QUANTUMSIM_EQASM_COMPILER_H

#include <ql/platform.h>
#include <ql/kernel.h>
#include <ql/gate.h>
#include <ql/ir.h>
#include <ql/scheduler.h>
#include <ql/eqasm_compiler.h>
#include <ql/mapper.h>

namespace ql
{
namespace arch
{

class quantumsim_eqasm_compiler : public eqasm_compiler
{
public:
    size_t num_qubits;
    size_t ns_per_cycle;

private:
    void write_qasm(std::stringstream& fname, std::vector<quantum_kernel>& kernels, ql::quantum_platform& platform)
    {
        size_t total_depth = 0;
        size_t total_quantum_gates = 0;
        size_t total_classical_operations = 0;
        std::stringstream out_qasm;
        out_qasm << "version 1.0\n";
        out_qasm << "# this file has been automatically generated by the OpenQL compiler please do not modify it manually.\n";
        out_qasm << "qubits " << platform.qubit_number << "\n";
        for(auto &kernel : kernels)
        {
            if (kernel.bundles.empty())
            {
                out_qasm << kernel.qasm();
            }
            else
            {
                out_qasm << "\n" << kernel.get_prologue();
                out_qasm << ql::ir::qasm(kernel.bundles);
                out_qasm << kernel.get_epilogue();
            }
            total_depth += kernel.get_depth();
            total_classical_operations += kernel.get_classical_operations();
            total_quantum_gates += kernel.get_quantum_gates();
        }
        out_qasm << "\n";
        out_qasm << "# Total depth: " << total_depth << "\n";
        out_qasm << "# Total no. of quantum gates: " << total_quantum_gates << "\n";
        out_qasm << "# Total no. of classical operations: " << total_classical_operations << "\n";
        out_qasm << "# No. kernels: " << kernels.size() << "\n";
        ql::utils::write_file(fname.str(), out_qasm.str());
    }

    void map(std::string& prog_name, std::vector<quantum_kernel>& kernels, ql::quantum_platform& platform)
    {
        for(auto &kernel : kernels)
        {
            // don't trust the cycle fields in the instructions
            // and let write_qasm print the circuit instead of the bundles
            kernel.bundles.clear();
        }

        std::stringstream mapper_in_fname;
        mapper_in_fname << ql::options::get("output_dir") << "/" << prog_name << "_mapper_in.qasm";
        IOUT("writing mapper input qasm to '" << mapper_in_fname.str() << "' ...");
        write_qasm(mapper_in_fname, kernels, platform);

        Mapper mapper;  // virgin mapper creation; for role of Init functions, see comment at top of mapper.h
        mapper.Init(platform); // platform specifies number of real qubits, i.e. locations for virtual qubits
        for(auto &kernel : kernels)
        {
            auto mapopt = ql::options::get("mapper");
            if (mapopt == "no" )
            {
                IOUT("Not mapping kernel");
                continue;;
            }
            IOUT("Mapping kernel: " << kernel.name);
            mapper.MapCircuit(kernel.qubit_count, kernel.c, kernel.name);
                            // kernel.qubit_count is number of virtual qubits, i.e. highest indexed qubit minus 1
                            // and kernel.qubit_count is updated to real highest index used minus -1
            kernel.bundles = mapper.Bundler(kernel.c);
            mapper.GetNumberOfSwapsAdded(kernel.swaps_added);
        }
        std::stringstream mapper_out_fname;
        mapper_out_fname << ql::options::get("output_dir") << "/" << prog_name << "_mapper_out.qasm";
        IOUT("writing mapper output qasm to '" << mapper_out_fname.str() << "' ...");
        write_qasm(mapper_out_fname, kernels, platform);
    }

    ql::ir::bundles_t quantumsim_schedule_rc(ql::circuit & ckt, 
        ql::quantum_platform & platform, size_t nqubits, size_t ncreg = 0)
    {
        IOUT("Resource constraint scheduling for quantumsim ...");
    
        scheduling_direction_t  direction;
        std::string schedopt = ql::options::get("scheduler");
        if ("ASAP" == schedopt)
        {
            direction = forward_scheduling;
        }
        else if ("ALAP" == schedopt)
        {
            direction = backward_scheduling;
        }
        else
        {
            EOUT("Unknown scheduler");
            throw ql::exception("Unknown scheduler!", false);
    
        }
        resource_manager_t rm(platform, direction);
    
        Scheduler sched;
        sched.Init(ckt, platform, nqubits, ncreg);
        ql::ir::bundles_t bundles;
        if ("ASAP" == schedopt)
        {
            bundles = sched.schedule_asap(rm, platform);
        }
        else if ("ALAP" == schedopt)
        {
            bundles = sched.schedule_alap(rm, platform);
        }
        else
        {
            EOUT("Unknown scheduler");
            throw ql::exception("Unknown scheduler!", false);
    
        }
    
        IOUT("Resource constraint scheduling for quantumsim [Done].");
        return bundles;
    }

    void schedule(std::string& prog_name, std::vector<quantum_kernel>& kernels, ql::quantum_platform& platform)
    {
        for(auto &kernel : kernels)
        {
            IOUT("Scheduling kernel: " << kernel.name);
            if (! kernel.c.empty())
            {
                auto num_creg = 0;  // quantumsim
                kernel.bundles = quantumsim_schedule_rc(kernel.c, platform, num_qubits, num_creg);
            }
        }
        std::stringstream rcscheduler_out_fname;
        rcscheduler_out_fname << ql::options::get("output_dir") << "/" << prog_name << "_rcscheduler_out.qasm";
        IOUT("writing rcscheduler output qasm to '" << rcscheduler_out_fname.str() << "' ...");
        write_qasm(rcscheduler_out_fname, kernels, platform);
    }

public:
    /*
     * compile qasm to quantumsim
     */
    // program level compilation
    void compile(std::string prog_name, std::vector<quantum_kernel> kernels, ql::quantum_platform& platform)
    {
        IOUT("Compiling " << kernels.size() << " kernels to generate quantumsim eQASM ... ");

        std::string params[] = { "qubit_number", "cycle_time" };
        size_t p = 0;
        try
        {
            num_qubits      = platform.hardware_settings[params[p++]];
            ns_per_cycle    = platform.hardware_settings[params[p++]];
        }
        catch (json::exception e)
        {
            throw ql::exception("[x] error : ql::quantumsim::compile() : error while reading hardware settings : parameter '"+params[p-1]+"'\n\t"+ std::string(e.what()),false);
        }

        map(prog_name, kernels, platform);

        schedule(prog_name, kernels, platform);

        // write scheduled bundles for quantumsim
        write_quantumsim_program(prog_name, num_qubits, kernels, platform);

        DOUT("Compiling CCLight eQASM [Done]");
    }

private:
    // write scheduled bundles for quantumsim
    void write_quantumsim_program( std::string prog_name, size_t num_qubits,
        std::vector<quantum_kernel>& kernels, ql::quantum_platform & platform)
    {
        IOUT("Writing scheduled Quantumsim program");
        ofstream fout;
        string qfname( ql::options::get("output_dir") + "/" + prog_name + "_quantumsim.py");
        IOUT("Writing scheduled Quantumsim program to " << qfname);
        fout.open( qfname, ios::binary);
        if ( fout.fail() )
        {
            EOUT("opening file " << qfname << std::endl
                     << "Make sure the output directory ("<< ql::options::get("output_dir") << ") exists");
            return;
        }

        fout << "# Quantumsim program generated OpenQL\n"
             << "# Please modify at your will to obtain extra information from Quantumsim\n\n"
             << "import numpy as np\n"
             << "from quantumsim.circuit import Circuit\n"
             << "from quantumsim.circuit import uniform_noisy_sampler\n"
             << endl;

        fout << "\n# create a circuit\n";
        fout << "c = Circuit(title=\"" << prog_name << "\")\n\n";

        DOUT("Adding qubits to Quantumsim program");
        fout << "\n# add qubits\n";
        for (json::iterator it = platform.resources.begin(); it != platform.resources.end(); ++it)
        {
            std::string n = it.key();
            if( n == "qubits")
            {
                size_t count =  platform.resources["qubits"]["count"];
                if(count > num_qubits)
                {
                    EOUT("qubit count is more than the qubits available in the platform");
                    throw ql::exception("[x] error : qubit count is more than the qubits available in the platform",false);
                }
                // TODO similarly, check also if the qubits used in program are less than or equal to count

                auto & T1s = platform.resources["qubits"]["T1"];
                auto & T2s = platform.resources["qubits"]["T2"];

                for( size_t q=0; q<num_qubits; q++ ) // TODO should be for qubits used in program
                {
                    fout << "c.add_qubit(\"q" << q <<"\", " << T1s[q] << ", " << T2s[q] << ")\n" ;
                }
            }
        }

        DOUT("Adding Gates to Quantumsim program");
        fout << "\n# add gates\n";
        for(auto &kernel : kernels)
        {
            for ( ql::ir::bundle_t & abundle : kernel.bundles)
            {
                auto bcycle = abundle.start_cycle;
    
                std::stringstream ssbundles;
                for( auto secIt = abundle.parallel_sections.begin(); secIt != abundle.parallel_sections.end(); ++secIt )
                {
                    for(auto insIt = secIt->begin(); insIt != secIt->end(); ++insIt )
                    {
                        auto & iname = (*insIt)->name;
                        auto & operands = (*insIt)->operands;
                        if( iname == "measure")
                        {
                            auto op = operands.back();
                            ssbundles << "\nsampler = uniform_noisy_sampler(readout_error=0.03, seed=42)\n";
                            ssbundles << "c.add_qubit(\"m" << op <<"\")\n";
                            ssbundles << "c.add_measurement("
                                      << "\"q" << op <<"\", "
                                      << "time=" << bcycle << ", "
                                      << "output_bit=\"m" << op <<"\", "
                                      << "sampler=sampler"
                                      << ")\n" ;
                        }
                        else
                        {
                            ssbundles <<  "c.add_"<< iname << "(" ;
                            size_t noperands = operands.size();
                            if( noperands > 0 )
                            {
                                for(auto opit = operands.begin(); opit != operands.end()-1; opit++ )
                                    ssbundles << "\"q" << *opit <<"\", ";
                                ssbundles << "\"q" << operands.back()<<"\"";
                            }
                            ssbundles << ", time=" << bcycle << ")" << endl;
                        }
                    }
                }
                fout << ssbundles.str();
            }
        }

        fout.close();
        IOUT("Writing scheduled Quantumsim program [Done]");
    }
};

} // arch
} // ql

#endif // QL_QUANTUMSIM_EQASM_COMPILER_H

