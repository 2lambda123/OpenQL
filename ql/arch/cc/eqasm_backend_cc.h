/**
 * @file   eqasm_backend_cc
 * @date   201807
 * @author
 * @brief  eqasm backend for the Central Controller
 * @remark based on cc_light_eqasm_compiler.h
 */

#ifndef QL_ARCH_CC_EQASM_BACKEND_CC_H
#define QL_ARCH_CC_EQASM_BACKEND_CC_H

#include <ql/platform.h>
#include <ql/ir.h>
#include <ql/circuit.h>
#include <ql/scheduler.h>
#include <ql/eqasm_compiler.h>
#include <ql/arch/cc_light/cc_light_resource_manager.h>

namespace ql
{
namespace arch
{

class eqasm_backend_cc : public eqasm_compiler
{
private:
    // parameters from JSON file:
    size_t qubit_number;    // num_qubits;
    size_t cycle_time;      // ns_per_cycle;
    size_t buffer_matrix[__operation_types_num__][__operation_types_num__];

    size_t total_exec_time = 0;

public:
    /*
     * compile for Central Controller (CCCODE)
     * NB: based on cc_light_eqasm_compiler.h, commit f34c0d9
     */

    void compile(std::string prog_name, std::vector<quantum_kernel> kernels, ql::quantum_platform& platform)
    {
        DOUT("Compiling " << kernels.size() << " kernels to generate CCCODE ... ");

        load_hw_settings(platform);


        // generate program header
        std::stringstream cccode;
        cccode << "# Program: " << prog_name << std::endl;
        cccode << "# Note:    generated by OpenQL Central Controller backend" << std::endl;

        // generate code for all kernels
        for(auto &kernel : kernels)
        {
            ql::circuit& ckt = kernel.c;
            if (!ckt.empty())
            {
                IOUT("Compiling kernel: " << kernel.name);
                cccode << "# Kernel:  " << kernel.name << std::endl;
                cccode << get_prologue(kernel);

                auto creg_count = kernel.creg_count;                        // FIXME: also take platform into account
                ql::circuit decomp_ckt;

                decompose_instructions(ckt, decomp_ckt, platform);          // decompose meta-instructions

#if 0   // FIXME: based on old code, disabled in cc_light_scheduler.h
                // schedule
                ql::ir::bundles_t bundles = cc_light_schedule(decomp_ckt, platform, qubit_number, creg_count);
#else
                // schedule with platform resource constraints
                ql::ir::bundles_t bundles = cc_light_schedule_rc(decomp_ckt, platform, qubit_number, creg_count);
                // FIXME: cc_light* is just available here because everything is in header files
#endif
                cccode << bundles2cccode(bundles, platform);
                cccode << get_epilogue(kernel);
            } else {
                WOUT("Empty kernel: " << kernel.name);
            }
        }

        cccode << "    stop" << std::endl;                                  // FIXME: cc_light loops whole program indefinitely

        // write CCCODE to file
        std::string file_name(ql::options::get("output_dir") + "/" + prog_name + ".cccode");
        IOUT("Writing CCCODE to " << file_name);
        ql::utils::write_file(file_name, cccode.str());

        DOUT("Compiling CCCODE [Done]");
    }


    void compile(std::string prog_name, ql::circuit& ckt, ql::quantum_platform& platform)
    {
        throw ql::exception("circuit compilation not implemented, because it does not support classical kernel operations");
    }


#if 0   // FIXME: potential additions, from cc_light
    // time analysis
    // total_exec_time = time_analysis();

    // compensate for latencies
    // compensate_latency();

    // reschedule
    // resechedule();

    // dump_instructions();

    // decompose meta-instructions
    // decompose_instructions();

    // reorder instructions
    // reorder_instructions();

    // insert waits

    emit_eqasm();
#endif




private:
    // based on: cc_light_eqasm_compiler.h
    void load_hw_settings(ql::quantum_platform& platform)
    {
        const struct {
            size_t  *var;
            std::string name;
        } hw_settings[] = {
            { &qubit_number,            "qubit_number"},
            { &cycle_time,              "cycle_time" },
#if 0   // FIXME: unused. Convert to cycle
            { &mw_mw_buffer,            "mw_mw_buffer" },
            { &mw_flux_buffer,          "mw_flux_buffer" },
            { &mw_readout_buffer,       "mw_readout_buffer" },
            { &flux_mw_buffer,          "flux_mw_buffer" },
            { &flux_flux_buffer,        "flux_flux_buffer" },
            { &flux_readout_buffer,     "flux_readout_buffer" },
            { &readout_mw_buffer,       "readout_mw_buffer" },
            { &readout_flux_buffer,     "readout_flux_buffer" },
            { &readout_readout_buffer,  "readout_readout_buffer" }
#endif
        };

        DOUT("Loading hardware settings ...");
        int i=0;
        try
        {
            for(i=0; i<sizeof(hw_settings)/sizeof(hw_settings[0]); i++) {
                size_t val = platform.hardware_settings[hw_settings[i].name];
                *hw_settings[i].var = val;
            }
        }
        catch (json::exception e)
        {
            throw ql::exception(
                "[x] error : ql::eqasm_compiler::compile() : error while reading hardware settings : parameter '"
                + hw_settings[i].name
                + "'\n\t"
                + std::string(e.what()), false);
        }
    }


    // based on: cc_light_eqasm_compiler.h
    void decompose_instructions(ql::circuit &ckt, ql::circuit &decomp_ckt, ql::quantum_platform &platform)
    {
        DOUT("decomposing instructions...");
        for( auto ins : ckt )
        {
            auto & iname =  ins->name;
            str::lower_case(iname);
            DOUT("decomposing instruction " << iname << "...");
            auto & iopers = ins->operands;
            int iopers_count = iopers.size();
            auto itype = ins->type();
            if(__classical_gate__ == itype)
            {
                DOUT("    classical instruction");

                if( (iname == "add") || (iname == "sub") ||
                    (iname == "and") || (iname == "or") || (iname == "xor") ||
                    (iname == "not") || (iname == "nop")
                  )
                {
                    // decomp_ckt.push_back(ins);
                    decomp_ckt.push_back(new ql::arch::classical_cc(iname, iopers));
                }
                else if( (iname == "eq") || (iname == "ne") || (iname == "lt") ||
                         (iname == "gt") || (iname == "le") || (iname == "ge")
                       )
                {
                    decomp_ckt.push_back(new ql::arch::classical_cc("cmp", {iopers[1], iopers[2]}));
                    decomp_ckt.push_back(new ql::arch::classical_cc("nop", {}));
                    decomp_ckt.push_back(new ql::arch::classical_cc("fbr_"+iname, {iopers[0]}));
                }
                else if(iname == "mov")
                {
                    // r28 is used as temp, TODO use creg properly to create temporary
                    decomp_ckt.push_back(new ql::arch::classical_cc("ldi", {28}, 0));
                    decomp_ckt.push_back(new ql::arch::classical_cc("add", {iopers[0], iopers[1], 28}));
                }
                else if(iname == "ldi")
                {
                    auto imval = ((ql::classical*)ins)->imm_value;
                    decomp_ckt.push_back(new ql::arch::classical_cc("ldi", iopers, imval));
                }
                else
                {
                    EOUT("Unknown decomposition of classical operation '" << iname << "' with '" << iopers_count << "' operands!");
                    throw ql::exception("Unknown classical operation '"+iname+"' with'"+std::to_string(iopers_count)+"' operands!", false);
                }
            }
            else
            {
                if(iname == "wait")
                {
                    DOUT("    wait instruction ");
                    decomp_ckt.push_back(ins);
                }
                else
                {
                    json& instruction_settings = platform.instruction_settings;
                    std::string operation_type;
                    if (instruction_settings.find(iname) != instruction_settings.end())
                    {
                        operation_type = instruction_settings[iname]["type"];
                    }
                    else
                    {
                        EOUT("instruction settings not found for '" << iname << "' with '" << iopers_count << "' operands!");
                        throw ql::exception("instruction settings not found for '"+iname+"' with'"+std::to_string(iopers_count)+"' operands!", false);
                    }
                    bool is_measure = (operation_type == "readout");
                    if(is_measure)
                    {
                        // insert measure
                        DOUT("    readout instruction ");
                        auto qop = iopers[0];
                        decomp_ckt.push_back(ins);
                        if( ql::gate_type_t::__custom_gate__ == itype )
                        {
                            auto & coperands = ins->creg_operands;
                            if(!coperands.empty())
                            {
                                auto cop = coperands[0];
                                decomp_ckt.push_back(new ql::arch::classical_cc("fmr", {cop, qop}));
                            }
                            else
                            {
                                WOUT("Unknown classical operand for measure/readout operation: '" << iname <<
                                    ". This will soon be depricated in favour of measure instruction with fmr" <<
                                    " to store measurement outcome to classical register.");
                            }
                        }
                        else
                        {
                            EOUT("Unknown decomposition of measure/readout operation: '" << iname << "!");
                            throw ql::exception("Unknown decomposition of measure/readout operation '"+iname+"'!", false);
                        }
                    }
                    else
                    {
                        DOUT("    quantum instruction ");
                        decomp_ckt.push_back(ins);
                    }
                }
            }
        }

#if 0   // originally commented out
        cc_light_eqasm_program_t decomposed;
        for (cc_light_eqasm_instruction * instr : cc_light_eqasm_instructions)
        {
        cc_light_eqasm_program_t dec = instr->decompose();
          for (cc_light_eqasm_instruction * i : dec)
             decomposed.push_back(i);
            }
            cc_light_eqasm_instructions.swap(decomposed);
#endif
        DOUT("decomposing instructions...[Done]");
    }


    // based on cc_light_eqasm_compiler.h::classical_instruction2qisa
    // NB: instructions defined in classical.h (also in JSON???)
    // also see cc_light_eqasm_compiler.h::decompose_instructions(), which produces "fmr" and friends
    std::string classical_instruction2cccode(ql::arch::classical_cc *classical_ins)
    {
        std::stringstream ssclassical;
        auto & iname =  classical_ins->name;
        auto & iopers = classical_ins->operands;
        int iopers_count = iopers.size();

        if(  (iname == "add") || (iname == "sub") ||
             (iname == "and") || (iname == "or") || (iname == "not") || (iname == "xor") ||
             (iname == "ldi") || (iname == "nop") || (iname == "cmp")
          )
        {
            ssclassical << iname;
            for(int i=0; i<iopers_count; ++i)
            {
                if(i==iopers_count-1)
                    ssclassical << " r" <<  iopers[i];
                else
                    ssclassical << " r" << iopers[i] << ",";
            }
            if(iname == "ldi")
            {
                ssclassical << ", " + std::to_string(classical_ins->imm_value);
            }
        }
        else if(iname == "fmr")
        {
            ssclassical << "fmr r" << iopers[0] << ", q" << iopers[1];
        }
        else if(iname == "fbr_eq")
        {
            ssclassical << "fbr " << "EQ, r" << iopers[0];
        }
        else if(iname == "fbr_ne")
        {
            ssclassical << "fbr " << "NE, r" << iopers[0];
        }
        else if(iname == "fbr_lt")
        {
            ssclassical << "fbr " << "LT, r" << iopers[0];
        }
        else if(iname == "fbr_gt")
        {
            ssclassical << "fbr " << "GT, r" << iopers[0];
        }
        else if(iname == "fbr_le")
        {
            ssclassical << "fbr " << "LE, r" << iopers[0];
        }
        else if(iname == "fbr_ge")
        {
            ssclassical << "fbr " << "GE, r" << iopers[0];
        }
        else
        {
            EOUT("Unknown CClight classical operation '" << iname << "' with '" << iopers_count << "' operands!");
            throw ql::exception("Unknown classical operation'"+iname+"' with'"+std::to_string(iopers_count)+"' operands!", false);
        }

        return ssclassical.str();
    }


    // based on cc_light_eqasm_compiler.h::get_prologue
    std::string get_prologue(ql::quantum_kernel &k)
    {
        std::stringstream ss;

        switch(k.type) {
            case kernel_type_t::IF_START:
                ss << "# IF_START" << std::endl;
#if 0
                // Branching macros are not yet supported by assembler,
                // so for now the following can not be used
                ss << "    b" << k.br_condition.inv_operation_name
                   <<" r" << (k.br_condition.operands[0])->id <<", r" << (k.br_condition.operands[1])->id
                   << ", " << k.name << "_end\n";
#else
                ss  <<"    cmp r" << (k.br_condition.operands[0])->id
                    <<", r" << (k.br_condition.operands[1])->id << '\n';
                ss  <<"    nop\n";
                ss  <<"    br " << k.br_condition.inv_operation_name << ", "
                    << k.name << "_end\n";
#endif
                break;

            case kernel_type_t::ELSE_START:
                ss << "# ELSE_START" << std::endl;
#if 0
                // Branching macros are not yet supported by assembler,
                // so for now the following can not be used
                ss << "    b" << k.br_condition.operation_name <<" r" << (k.br_condition.operands[0])->id
                   <<", r" << (k.br_condition.operands[1])->id << ", " << k.name << "_end\n";
#else
                ss  <<"    cmp r" << (k.br_condition.operands[0])->id
                    <<", r" << (k.br_condition.operands[1])->id << '\n';
                ss  <<"    nop\n";
                ss  <<"    br " << k.br_condition.operation_name << ", "
                    << k.name << "_end\n";
#endif
                break;

            case kernel_type_t::FOR_START:
                ss << "# FOR_START(" << k.iterations << ")" << std::endl;
                // for now r29, r30, r31 are used as temporaries
                ss << "    ldi r29" <<", " << k.iterations << "\n";
                ss << "    ldi r30" <<", " << 1 << "\n";
                ss << "    ldi r31" <<", " << 0 << "\n";
                break;

            default:
                // nothing to do for other types
                break;
        }
        return ss.str();
    }



    // based on cc_light_eqasm_compiler.h::get_epilogue
    std::string get_epilogue(ql::quantum_kernel &k)
    {
        std::stringstream ss;

        switch(k.type) {
            case kernel_type_t::DO_WHILE_END:
                ss << "# DO_WHILE_END" << std::endl;
#if 0
                // Branching macros are not yet supported by assembler,
                // so for now the following can not be used
                ss << "    b" << k.br_condition.operation_name <<" r" << (k.br_condition.operands[0])->id
                   <<", r" << (k.br_condition.operands[1])->id << ", " << k.name << "_start\n";
#else
                ss  <<"    cmp r" << (k.br_condition.operands[0])->id
                    <<", r" << (k.br_condition.operands[1])->id << '\n';
                ss  <<"    nop\n";
                ss  <<"    br " << k.br_condition.operation_name << ", "
                    << k.name << "_start\n";
#endif
                break;

            case kernel_type_t::FOR_END:
            {
                // get label from kernel name
                std::string kname(k.name);
                std::replace( kname.begin(), kname.end(), '_', ' ');
                std::istringstream iss(kname);
                std::vector<std::string> tokens{ std::istream_iterator<std::string>{iss},
                                                 std::istream_iterator<std::string>{} };

                ss << "# FOR_END" << std::endl;
                // for now r29, r30, r31 are used
                ss << "    add r31, r31, r30\n";
#if 0
                // Branching macros are not yet supported by assembler,
                // so for now the following can not be used
                ss << "    blt r31, r29, " << tokens[0] << "\n";
#else
                ss  <<"    cmp r31, r29\n";
                ss  <<"    nop\n";
                ss  <<"    br lt, " << tokens[0] << "\n";
#endif
                break;
            }

            default:
                // nothing to do for other types
                break;
        }
        return ss.str();
    }


    // based on bundles2qisa()
    std::string bundles2cccode(ql::ir::bundles_t &bundles, ql::quantum_platform &platform)
    {
        IOUT("Generating CCCODE for bundles");

        std::stringstream ssbundles;
        size_t curr_cycle = 0;

        for(ql::ir::bundle_t &bundle : bundles)
        {
            auto delta = bundle.start_cycle - curr_cycle;
            bool classical_bundle = false;
            std::stringstream sspre, ssinst;

#if 0   // FIXME: later
            if(delta < 8)
                sspre << "    " << delta << "    ";
            else
                sspre << "    qwait " << delta-1 << "\n"
                      << "    1    ";
#endif

            for(auto section = bundle.parallel_sections.begin(); section != bundle.parallel_sections.end(); ++section )
            {
                //auto firstInsIt = section->begin();
                auto firstInstr = *section->begin();
                std::string iname = firstInstr->name;
                auto itype = firstInstr->type();
                qubit_set_t squbits;
                qubit_pair_set_t dqubits;

                if(__classical_gate__ == itype)
                {
                    classical_bundle = true;
#if 1   // FIXME:later
                    ssinst << classical_instruction2cccode( (ql::arch::classical_cc *)firstInstr );
#else
                    DOUT("FIXME: skipping classical instruction: " << iname);
#endif
                }
                else
                {
                    // translate instruction name (e.g. "x q5") to the contents of JSON field "cc_light_instr" (e.g. "x")
                    DOUT("get cc_light_instr for : " << iname);
                    std::string cc_light_instr;
                    auto it = platform.instruction_map.find(iname);
                    if (it != platform.instruction_map.end())
                    {
                        custom_gate* g = it->second;
                        cc_light_instr = g->arch_operation_name;    // NB: assigned in gate.h::load(json& instr)
                        if(cc_light_instr.empty())
                        {
                            EOUT("cc_light_instr not defined for instruction: " << iname << " !");
                            throw ql::exception("Error : cc_light_instr not defined for instruction: "+iname+" !",false);
                        }
#if 1
                        else {
                            DOUT("and it is: " << cc_light_instr);
                        }
#endif
                    }
                    else
                    {
                        EOUT("custom instruction not found for : " << iname << " !");
                        throw ql::exception("Error : custom instruction not found for : "+iname+" !",false);
                    }

                    auto nOperands = (firstInstr->operands).size();
                    if( itype == __nop_gate__ )
                    {
                        ssinst << cc_light_instr;
                    }
                    else
                    {
                        for(auto insIt = section->begin(); insIt != section->end(); ++insIt )
                        {
                            if( 1 == nOperands )
                            {
                                auto & op = (*insIt)->operands[0];
                                squbits.push_back(op);
                            }
                            else if( 2 == nOperands )
                            {
                                auto & op1 = (*insIt)->operands[0];
                                auto & op2 = (*insIt)->operands[1];
                                dqubits.push_back( qubit_pair_t(op1,op2) );
                            }
                            else
                            {
                                throw ql::exception("Error : only 1 and 2 operand instructions are supported by cc light masks !",false);
                            }
                        }
                        std::string rname;
#if 0   // FIXME: later
                        if( 1 == nOperands )
                        {
                            rname = gMaskManager.getRegName(squbits);
                        }
                        else if( 2 == nOperands )
                        {
                            rname = gMaskManager.getRegName(dqubits);
                        }
                        else
                        {
                            throw ql::exception("Error : only 1 and 2 operand instructions are supported by cc light masks !",false);
                        }
#endif
                        ssinst << cc_light_instr << " " << rname;
                    }

                    if( std::next(section) != bundle.parallel_sections.end() )
                    {
                        ssinst << " | ";
                    }
                }
            }

#if 0   // insert qwaits
            if(classical_bundle)
            {
                if(iname == "fmr")  // FIXME: this is cc_light instruction
                {
                    // based on cclight requirements (section 4.7 eqasm manual),
                    // two extra instructions need to be added between meas and fmr
                    if(delta > 2)
                    {
                        ssbundles << "    qwait " << 1 << "\n";
                        ssbundles << "    qwait " << delta-1 << "\n";
                    }
                    else
                    {
                        ssbundles << "    qwait " << 1 << "\n";
                        ssbundles << "    qwait " << 1 << "\n";
                    }
                }
                else
                {
                    if(delta > 1)
                        ssbundles << "    qwait " << delta << "\n";
                }
                ssbundles << "    " << ssinst.str() << "\n";
            }
            else
            {
                ssbundles << sspre.str() << ssinst.str() << "\n";
            }
#endif

            curr_cycle += delta;
        }

        auto & lastBundle = bundles.back();
        int lbduration = lastBundle.duration_in_cycles;
        if( lbduration>1 )
            ssbundles << "    qwait " << lbduration << "\n";

        IOUT("Generating CCCODE for bundles [Done]");
        return ssbundles.str();
    }
}; // class

} // arch
} // ql

#endif // QL_ARCH_CC_EQASM_BACKEND_CC_H

