/**
 * @file   eqasm_backend_cc
 * @date   201809xx
 * @author Wouter Vlothuizen (wouter.vlothuizen@tno.nl)
 * @brief  eqasm backend for the Central Controller
 * @remark based on cc_light_eqasm_compiler.h
 */

#ifndef QL_ARCH_CC_EQASM_BACKEND_CC_H
#define QL_ARCH_CC_EQASM_BACKEND_CC_H

#include <ql/platform.h>
#include <ql/ir.h>
#include <ql/circuit.h>
#include <ql/scheduler.h>
#include <ql/eqasm_compiler.h>
#include <ql/arch/cc_light/cc_light_resource_manager.h>

#include "codegen_cc.h"


// define classical QASM instructions as generated by classical.h
// FIXME: should be moved to a more sensible location
// FIXME: is "wait" also an instruction, and is is different from "nop"?
#define QASM_CLASSICAL_INSTRUCTION_LIST   \
    X(QASM_ADD, "add") \
    X(QASM_SUB, "sub") \
    X(QASM_AND, "and") \
    X(QASM_OR, "or")   \
    X(QASM_XOR, "xor") \
    X(QASM_NOT, "not") \
    X(QASM_NOP, "nop") \
    X(QASM_LDI, "ldi") \
    X(QASM_MOV, "mov") \
    X(QASM_EQ, "eq")   \
    X(QASM_NE, "ne")   \
    X(QASM_LT, "lt")   \
    X(QASM_GT, "gt")   \
    X(QASM_LE, "le")   \
    X(QASM_GE, "ge")

#if 0
// generate enum for instructions
#define X(_enum, _string) _enum
enum eQASM {
    QASM_CLASSICAL_INSTRUCTION_LIST
};
#undef X
#endif


// generate constants for instructions
#define X(_enum, _string) const char *_enum = _string;
QASM_CLASSICAL_INSTRUCTION_LIST
#undef X





namespace ql
{
namespace arch
{

class eqasm_backend_cc : public eqasm_compiler
{
private:
    // parameters from JSON file:
    size_t qubit_number;    // num_qubits;
    size_t cycle_time;      // ns_per_cycle;
    size_t buffer_matrix[__operation_types_num__][__operation_types_num__];

    size_t total_exec_time = 0;
    bool verboseCode = true;    // output extra comments in generated code. FIXME: being moved to codegen
    codegen_cc codegen;

public:
    /*
     * compile for Central Controller (CCCODE)
     * NB: based on cc_light_eqasm_compiler.h, commit f34c0d9
     */

    void compile(std::string prog_name, std::vector<quantum_kernel> kernels, ql::quantum_platform& platform)
    {
#if 1   // FIXME: patch for issue #164, should be moved to caller
        if(kernels.size() == 0) {
            FATAL("Trying to compile empty kernel");
        }
#endif
        DOUT("Compiling " << kernels.size() << " kernels to generate CCCODE ... ");
        load_backend_settings(platform);
        load_hw_settings(platform);

        // generate program header
        std::stringstream cccode;
        codegen.program_header(cccode, prog_name);

        // generate code for all kernels
        for(auto &kernel : kernels) {
            IOUT("Compiling kernel: " << kernel.name);
            if(verboseCode) cccode << "# Kernel:  " << kernel.name << std::endl;
            cccode << get_prologue(kernel);

            ql::circuit& ckt = kernel.c;
            if (!ckt.empty()) {
                auto creg_count = kernel.creg_count;                        // FIXME: also take platform into account
                ql::circuit decomp_ckt;

//                decompose_instructions(ckt, decomp_ckt, platform);          // decompose meta-instructions

#if 0   // FIXME: based on old code, disabled in cc_light_scheduler.h
                // schedule
                ql::ir::bundles_t bundles = cc_light_schedule(decomp_ckt, platform, qubit_number, creg_count);
#else
                // schedule with platform resource constraints
//                ql::ir::bundles_t bundles = cc_light_schedule_rc(decomp_ckt, platform, qubit_number, creg_count);
                // FIXME: we removed decompose_instructions, but can cc_light_schedule_rc live with that? Apparently it's not to bad
                ql::ir::bundles_t bundles = cc_light_schedule_rc(ckt, platform, qubit_number, creg_count);
                // FIXME: cc_light* is just available here because everything is in header files
#endif
                cccode << bundles2cccode(bundles, platform);
            } else {
                DOUT("Empty kernel: " << kernel.name);                      // NB: normal situation for kernels with classical control
            }

            cccode << get_epilogue(kernel);
        }

        codegen.finish(cccode);

        // write CCCODE to file
        std::string file_name(ql::options::get("output_dir") + "/" + prog_name + ".cccode");
        IOUT("Writing CCCODE to " << file_name);
        ql::utils::write_file(file_name, cccode.str());

        DOUT("Compiling CCCODE [Done]");
    }


    void compile(std::string prog_name, ql::circuit& ckt, ql::quantum_platform& platform)
    {
        FATAL("circuit compilation not implemented, because it does not support classical kernel operations");
    }


#if 0   // FIXME: potential additions, from cc_light
    // time analysis
    // total_exec_time = time_analysis();

    // compensate for latencies
    // compensate_latency();

    // reschedule
    // resechedule();

    // dump_instructions();

    // decompose meta-instructions
    // decompose_instructions();

    // reorder instructions
    // reorder_instructions();

    // insert waits

    emit_eqasm();
#endif




private:
    // FIXME: being moved to codegen
    // some helpers to ease nice assembly formatting
    void emit(std::stringstream &s, const char *labelOrComment, const char *instr="")
    {
        s << std::left;    // FIXME
        if(!labelOrComment || strlen(labelOrComment)==0) {  // no label
            s << "        " << instr << std::endl;
        } else if(strlen(labelOrComment)<8) {               // label fits before instr
            s << std::setw(8) << labelOrComment << instr << std::endl;
        } else if(strlen(instr)==0) {                       // no instr
            s << labelOrComment << std::endl;
        } else {
            s << labelOrComment << std::endl << "        " << instr << std::endl;
        }
    }

    // @param   label       must include trailing ":"
    // @param   comment     must include leading "#"
    void emit(std::stringstream &s, const char *label, const char *instr, std::string ops, const char *comment="")
    {
        s << std::left;    // FIXME
        s << std::setw(8) << label << std::setw(8) << instr << std::setw(16) << ops << comment << std::endl;
    }


    void load_backend_settings(ql::quantum_platform& platform)
    {
        // FIXME: we would like to have a top level setting, or one below "backends"
        // it is however not easy to create new top level stuff and read it from the backend
//        try
        {
            auto backendSettings = platform.hardware_settings["eqasm_backend_cc"];

            // read instrument definitions
            auto instrumentDefinitions = backendSettings["instrument-definitions"];
            const char *knownInstrDef[] = {"cc", "switch", "awg", "measure"};
            for(int i=0; i<ELEM_CNT(knownInstrDef); i++)
            {
                auto id = instrumentDefinitions[knownInstrDef[i]];
                for(int j=0; j<id.size(); j++)
                {
                    auto name = id[j]["name"];
                    DOUT("found instrument definition for '" << name <<"'");
                }
            }

            // read instruments
            auto instruments = backendSettings["instruments"];
        }
#if 0
        catch (json::exception e)
        {
            throw ql::exception(
                "[x] error : ql::eqasm_compiler::compile() : error while reading backend settings : parameter '"
//                + hw_settings[i].name
                + "'\n\t"
                + std::string(e.what()), false);
        }
#endif
    }


    // based on: cc_light_eqasm_compiler.h::load_hw_settings
    void load_hw_settings(ql::quantum_platform& platform)
    {
        const struct {
            size_t  *var;
            std::string name;
        } hw_settings[] = {
            { &qubit_number,            "qubit_number"},
            { &cycle_time,              "cycle_time" },
#if 0   // FIXME: unused. Convert to cycle
            { &mw_mw_buffer,            "mw_mw_buffer" },
            { &mw_flux_buffer,          "mw_flux_buffer" },
            { &mw_readout_buffer,       "mw_readout_buffer" },
            { &flux_mw_buffer,          "flux_mw_buffer" },
            { &flux_flux_buffer,        "flux_flux_buffer" },
            { &flux_readout_buffer,     "flux_readout_buffer" },
            { &readout_mw_buffer,       "readout_mw_buffer" },
            { &readout_flux_buffer,     "readout_flux_buffer" },
            { &readout_readout_buffer,  "readout_readout_buffer" }
#endif
        };

        DOUT("Loading hardware settings ...");
        int i=0;
        try
        {
            for(i=0; i<ELEM_CNT(hw_settings); i++) {
                size_t val = platform.hardware_settings[hw_settings[i].name];
                *hw_settings[i].var = val;
            }
        }
        catch (json::exception e)
        {
            throw ql::exception(
                "[x] error : ql::eqasm_compiler::compile() : error while reading hardware settings : parameter '"
                + hw_settings[i].name
                + "'\n\t"
                + std::string(e.what()), false);
        }
    }


    // based on cc_light_eqasm_compiler.h::classical_instruction2qisa/decompose_instructions
    // NB: input instructions defined in classical.h::classical (also in JSON???)
    std::string classical_instruction2cccode(ql::gate *classical_ins)
    {
        std::stringstream ret;
        auto & iname =  classical_ins->name;
        auto & iopers = classical_ins->operands;
        int iopers_count = iopers.size();

        if(  (iname == QASM_ADD) || (iname == QASM_SUB) ||
             (iname == QASM_AND) || (iname == QASM_OR) || (iname == QASM_NOT) || (iname == QASM_XOR) ||
             (iname == QASM_LDI) || (iname == QASM_MOV) ||
             (iname == QASM_NOP)
          )
        // FIXME: adapt for CC, this is still CC-light
        {
            ret << iname;
            for(int i=0; i<iopers_count; ++i)
            {
                if(i==iopers_count-1)
                    ret << " r" <<  iopers[i];
                else
                    ret << " r" << iopers[i] << ",";
            }
            if(iname == QASM_LDI)
            {
//                ret << ", " + std::to_string(classical_ins->imm_value);
            }
        }

        // inserted from decompose_instructions
        else if( (iname == QASM_EQ) || (iname == QASM_NE) || (iname == QASM_LT) ||
                 (iname == QASM_GT) || (iname == QASM_LE) || (iname == QASM_GE)
               )
        {
        }
        else
        {
            FATAL("Unknown classical operation'" << iname << "' with'" << iopers_count << "' operands!");
        }

        return ret.str();
    }


    // get label from kernel name: FIXME: the label is the program name
    // FIXME: the kernel name has a structure (e.g. "sp1_for1_start" or "sp1_for1_start") which we use here. This should be made explicit
    // FIXME: looks very inefficient
    // extracted from get_epilogue
    std::string kernelLabel(ql::quantum_kernel &k)
    {
        std::string kname(k.name);
        std::replace(kname.begin(), kname.end(), '_', ' ');
        std::istringstream iss(kname);
        std::vector<std::string> tokens{ std::istream_iterator<std::string>{iss},
                                         std::istream_iterator<std::string>{} };
        return tokens[0];
    }


    // find operation type for custom gate
    // FIXME: move to generic location
    std::string findInstructionType(ql::quantum_platform &platform, std::string iname)
    {
        // walk the JSON defined instructions
        json& instruction_settings = platform.instruction_settings;
        std::string instruction_type;
        if (instruction_settings.find(iname) == instruction_settings.end())
        {
            FATAL("instruction settings not found for '" << iname << "'!");
        }

        instruction_type = instruction_settings[iname]["type"];
        return instruction_type;
    }


    // based on cc_light_eqasm_compiler.h::get_prologue
    std::string get_prologue(ql::quantum_kernel &k)
    {
        std::stringstream ret;

        switch(k.type) {
            case kernel_type_t::IF_START:
            {
                auto op0 = k.br_condition.operands[0]->id;
                auto op1 = k.br_condition.operands[1]->id;
                auto opName = k.br_condition.operation_name;
                codegen.if_start(ret, op0, opName, op1);
                break;
            }

            case kernel_type_t::ELSE_START:
            {
                auto op0 = k.br_condition.operands[0]->id;
                auto op1 = k.br_condition.operands[1]->id;
                auto opName = k.br_condition.operation_name;
                codegen.else_start(ret, op0, opName, op1);
                break;
            }

            case kernel_type_t::FOR_START:
            {
                std::string label = kernelLabel(k);
                codegen.for_start(ret, label, k.iterations);
                break;
            }

            case kernel_type_t::DO_WHILE_START:
            {
                std::string label = kernelLabel(k);
                codegen.do_while_start(ret, label);
                break;
            }

            default:
                // nothing to do for other types
                break;
        }
        return ret.str();
    }


    // based on cc_light_eqasm_compiler.h::get_epilogue
    std::string get_epilogue(ql::quantum_kernel &k)
    {
        std::stringstream ret;

        switch(k.type) {
            case kernel_type_t::FOR_END:
            {
                std::string label = kernelLabel(k);
                codegen.for_end(ret, label);
                break;
            }

            case kernel_type_t::DO_WHILE_END:
            {
                auto op0 = k.br_condition.operands[0]->id;
                auto op1 = k.br_condition.operands[1]->id;
                auto opName = k.br_condition.operation_name;
                codegen.do_while_end(ret, op0, opName, op1);
                break;
            }

            default:
                // nothing to do for other types
                // FIXME: true for IF_END, ELSE_END?
                break;
        }
        return ret.str();
    }


    // based on cc_light_eqasm_compiler.h::bundles2qisa()
    std::string bundles2cccode(ql::ir::bundles_t &bundles, ql::quantum_platform &platform)
    {
        IOUT("Generating CCCODE for bundles");
        std::stringstream ret;
        size_t curr_cycle = 0;

        for(ql::ir::bundle_t &bundle : bundles)
        {
            auto delta = bundle.start_cycle - curr_cycle;
            bool classical_bundle = false;
            std::stringstream sspre, ssinst;

            // generate bundle header
#if 0   // FIXME: later. Is it necessary to split sspre and ssinst?
            // delay start of bundle
            if(delta < 8)
                sspre << "    " << delta << "    ";
            else
                sspre << "    qwait " << delta-1 << "\n"
                      << "    1    ";
#endif

            // generate code for this bundle
            for(auto section = bundle.parallel_sections.begin(); section != bundle.parallel_sections.end(); ++section ) {
                // check whether section defines classical gate
                ql::gate *firstInstr = *section->begin();
                auto firstInstrType = firstInstr->type();
                if(firstInstrType == __classical_gate__) {
                    if(section->size() != 1) {
                        FATAL("Inconsistency detected: classical gate with parallel sections");
                    }
                    classical_bundle = true;
                    ssinst << classical_instruction2cccode(firstInstr);
                } else {
                    /* iterate over all instructions in section.
                     * NB: strategy differs from cc_light_eqasm_compiler, we have no special treatment of first instruction
                     * and don't require all instructions to be identical
                     */
                    for(auto insIt = section->begin(); insIt != section->end(); ++insIt) {
                        ql::gate *instr = *insIt;
                        ql::gate_type_t itype = instr->type();
                        std::string iname = instr->name;
                        std::string instr_name = platform.get_instruction_name(iname);

                        if(itype == __nop_gate__)       // a quantum "nop", see gate.h
                        {
                            //FIXME: does a __nop_gate__ ever get a cc_light_instr (which are defined in JSON)?
                            codegen.nop(ssinst);
                        } else if(itype == __classical_gate__) {
                            FATAL("Inconsistency detected: classical gate found after first section");
                        // FIXME: do we also need to test for other itype like __measure_gate__, __display__??
                        } else {    // 'normal' gate
                            auto nOperands = instr->operands.size();
                            auto nCoperands = instr->creg_operands.size();

                            // handle readout (extracted from decompose_instructions)
                            if("readout" == findInstructionType(platform, iname))
                            {
                                DOUT("    readout instruction ");
                                if(itype != __custom_gate__) {
                                    FATAL("Readout instruction '" << iname << "' must be a custom gate"); // FIXME: unclear message
                                }
                                if(nCoperands != 1) {
                                    FATAL("Readout instruction requires exactly 1 classical operand");
                                }
                                if(nOperands != 1) {
                                    FATAL("Readout instruction requires exactly 1 qubit operand");
                                }

                                auto &op0 = instr->operands[0];
                                auto &cop0 = instr->creg_operands[0];
                                codegen.readout(ssinst, cop0, op0);
                            } else { // handle all other instruction types
                                if(1 == nOperands) {
                                    auto &op0 = instr->operands[0];
                                    if(verboseCode) emit(ssinst, SS2S("# " << instr_name << " " << op0).c_str());
    //                                squbits.push_back(op);

                                    /* we may have an "x" on 0:
                                       - that implies an "x" [gauss-r, gauss-i, derGauss-r, derGauss-i] on AWGx channelGroup y. Identical for several qubits, depending on topology
                                       - or without a VSM: [gauss-0, derGauss-0]
                                       - and an enable on VSM channel z
                                       or a "cnot" on 2,3
                                       - that implies a "cnot-src-1" on 1 and a cnot-dst-3" on 3 on AWGx
                                        Note that we can use a QWG (4 channels) or a pair of QWG, or a AWG-8, in different codeword modes
                                    */


                                } else if(2 == nOperands) {
                                    auto &op0 = instr->operands[0];
                                    auto &op1 = instr->operands[1];
                                    if(verboseCode) emit(ssinst, SS2S("# " << instr_name << " " << op0 << "," << op1).c_str());
    //                                dqubits.push_back(qubit_pair_t(op1, op2));
                                } else {
                                    FATAL("Only 1 and 2 operand instructions are supported !");
                                }
                            }
                        }


#if 0   // FIXME: cc_light SMIS/SMIT handling
                        std::string rname;
                        if( 1 == nOperands )
                        {
                            rname = gMaskManager.getRegName(squbits);
                        }
                        else if( 2 == nOperands )
                        {
                            rname = gMaskManager.getRegName(dqubits);
                        }
                        else
                        {
                            throw ql::exception("Error : only 1 and 2 operand instructions are supported by cc light masks !",false);
                        }
                        ssinst << instr_name << " " << rname;
#endif
                    }


#if 0
                    if(std::next(section) != bundle.parallel_sections.end()) {
                        ssinst << " | ";
                    }
#endif
                }
            }


            // generate bundle trailer
#if 0   // insert qwaits
            if(classical_bundle)
            {
                if(iname == "fmr")  // FIXME: this is cc_light instruction
                {
                    // based on cclight requirements (section 4.7 eqasm manual),
                    // two extra instructions need to be added between meas and fmr
                    if(delta > 2)
                    {
                        ret << "    qwait " << 1 << "\n";
                        ret << "    qwait " << delta-1 << "\n";
                    }
                    else
                    {
                        ret << "    qwait " << 1 << "\n";
                        ret << "    qwait " << 1 << "\n";
                    }
                }
                else
                {
                    if(delta > 1)
                        ret << "    qwait " << delta << "\n";
                }
                ret << "    " << ssinst.str() << "\n";
            }
            else
#endif
            {
                ret << sspre.str() << ssinst.str() << "\n";
            }

            curr_cycle += delta;
        }

#if 0   // FIXME: CC-light
        auto &lastBundle = bundles.back();
        int lbduration = lastBundle.duration_in_cycles;
        if(lbduration > 1)
            ret << "    qwait " << lbduration << "\n";
#endif

        IOUT("Generating CCCODE for bundles [Done]");
        return ret.str();
    }
}; // class

} // arch
} // ql

#endif // QL_ARCH_CC_EQASM_BACKEND_CC_H

