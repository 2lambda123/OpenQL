/**
 * @file   eqasm_backend_cc
 * @date   201809xx
 * @author Wouter Vlothuizen (wouter.vlothuizen@tno.nl)
 * @brief  eqasm backend for the Central Controller
 * @remark based on cc_light_eqasm_compiler.h, commit f34c0d9
 */

#ifndef QL_ARCH_CC_EQASM_BACKEND_CC_H
#define QL_ARCH_CC_EQASM_BACKEND_CC_H

#include <ql/platform.h>
#include <ql/ir.h>
#include <ql/circuit.h>
#include <ql/scheduler.h>
#include <ql/eqasm_compiler.h>
#include <ql/arch/cc_light/cc_light_resource_manager.h>

#include "codegen_cc.h"

using json = nlohmann::json;


// define classical QASM instructions as generated by classical.h
// FIXME: should be moved to a more sensible location
// FIXME: is "wait" also an instruction, and is is different from "nop"?
#define QASM_CLASSICAL_INSTRUCTION_LIST   \
    X(QASM_ADD, "add") \
    X(QASM_SUB, "sub") \
    X(QASM_AND, "and") \
    X(QASM_OR, "or")   \
    X(QASM_XOR, "xor") \
    X(QASM_NOT, "not") \
    X(QASM_NOP, "nop") \
    X(QASM_LDI, "ldi") \
    X(QASM_MOV, "mov") \
    X(QASM_EQ, "eq")   \
    X(QASM_NE, "ne")   \
    X(QASM_LT, "lt")   \
    X(QASM_GT, "gt")   \
    X(QASM_LE, "le")   \
    X(QASM_GE, "ge")

#if 0
// generate enum for instructions
#define X(_enum, _string) _enum
enum eQASM {
    QASM_CLASSICAL_INSTRUCTION_LIST
};
#undef X
#endif


// generate constants for instructions
#define X(_enum, _string) const char *_enum = _string;
QASM_CLASSICAL_INSTRUCTION_LIST
#undef X





namespace ql
{
namespace arch
{

class eqasm_backend_cc : public eqasm_compiler
{
private:
    codegen_cc codegen;
    size_t total_exec_time = 0;

    // parameters from JSON file:
    size_t qubit_number;    // num_qubits;
    size_t cycle_time;      // ns_per_cycle;
    size_t buffer_matrix[__operation_types_num__][__operation_types_num__];

public:

    // compile for Central Controller (CCCODE)
    void compile(std::string prog_name, std::vector<quantum_kernel> kernels, ql::quantum_platform& platform)
    {
#if 1   // FIXME: patch for issue #164, should be moved to caller
        if(kernels.size() == 0) {
            FATAL("Trying to compile empty kernel");
        }
#endif
        DOUT("Compiling " << kernels.size() << " kernels to generate CCCODE ... ");

        load_hw_settings(platform);
        codegen.init(platform);

        // generate program header
        std::stringstream cccode;
        codegen.program_header(cccode, prog_name);

        // generate code for all kernels
        for(auto &kernel : kernels) {
            IOUT("Compiling kernel: " << kernel.name);
            cccode << codegen_kernel_prologue(kernel);

            ql::circuit& ckt = kernel.c;
            if (!ckt.empty()) {
                auto creg_count = kernel.creg_count;                        // FIXME: also take platform into account. We get qubit_number from JSON
                ql::circuit decomp_ckt;

//                decompose_instructions(ckt, decomp_ckt, platform);          // decompose meta-instructions

#if 0   // FIXME: based on old code, disabled in cc_light_scheduler.h
                // schedule
                ql::ir::bundles_t bundles = cc_light_schedule(decomp_ckt, platform, qubit_number, creg_count);
#else
                // schedule with platform resource constraints
//                ql::ir::bundles_t bundles = cc_light_schedule_rc(decomp_ckt, platform, qubit_number, creg_count);
                // FIXME: we removed decompose_instructions, but can cc_light_schedule_rc live with that? Apparently it's not too bad
                ql::ir::bundles_t bundles = cc_light_schedule_rc(ckt, platform, qubit_number, creg_count);
                // FIXME: cc_light* is just available here because everything is in header files
#endif
                cccode << codegen_bundles(bundles, platform);
            } else {
                DOUT("Empty kernel: " << kernel.name);                      // NB: normal situation for kernels with classical control
            }

            cccode << codegen_kernel_epilogue(kernel);
        }

        codegen.program_trailer(cccode);

        // write CCCODE to file
        std::string file_name(ql::options::get("output_dir") + "/" + prog_name + ".cccode");
        IOUT("Writing CCCODE to " << file_name);
        ql::utils::write_file(file_name, cccode.str());

        DOUT("Compiling CCCODE [Done]");
    }


    void compile(std::string prog_name, ql::circuit& ckt, ql::quantum_platform& platform)
    {
        FATAL("circuit compilation not implemented, because it does not support classical kernel operations");
    }


#if 0   // FIXME: potential additions, from cc_light
    // time analysis
    // total_exec_time = time_analysis();

    // compensate for latencies
    // compensate_latency();

    // reschedule
    // resechedule();

    // dump_instructions();

    // decompose meta-instructions
    // decompose_instructions();

    // reorder instructions
    // reorder_instructions();

    // insert waits

    emit_eqasm();
#endif




private:
    // based on cc_light_eqasm_compiler.h::classical_instruction2qisa/decompose_instructions
    // NB: input instructions defined in classical.h::classical (also in JSON???)
    std::string codegen_classical_instruction(ql::gate *classical_ins)
    {
        std::stringstream ret;
        auto & iname =  classical_ins->name;
        auto & iopers = classical_ins->operands;
        int iopers_count = iopers.size();

        if(  (iname == QASM_ADD) || (iname == QASM_SUB) ||
             (iname == QASM_AND) || (iname == QASM_OR) || (iname == QASM_NOT) || (iname == QASM_XOR) ||
             (iname == QASM_LDI) || (iname == QASM_MOV) ||
             (iname == QASM_NOP)
          )
        // FIXME: adapt for CC, this is still CC-light
        {
            ret << iname;
            for(int i=0; i<iopers_count; ++i)
            {
                if(i==iopers_count-1)
                    ret << " r" <<  iopers[i];
                else
                    ret << " r" << iopers[i] << ",";
            }
            if(iname == QASM_LDI)
            {
//                ret << ", " + std::to_string(classical_ins->imm_value);
            }
        }

        // inserted from decompose_instructions
        else if( (iname == QASM_EQ) || (iname == QASM_NE) || (iname == QASM_LT) ||
                 (iname == QASM_GT) || (iname == QASM_LE) || (iname == QASM_GE)
               )
        {
        }
        else
        {
            FATAL("Unknown classical operation'" << iname << "' with'" << iopers_count << "' operands!");
        }

        return ret.str();
    }


    // get label from kernel name: FIXME: the label is the program name
    // FIXME: the kernel name has a structure (e.g. "sp1_for1_start" or "sp1_for1_start") which we use here. This should be made explicit
    // FIXME: looks very inefficient
    // extracted from get_epilogue
    std::string kernelLabel(ql::quantum_kernel &k)
    {
        std::string kname(k.name);
        std::replace(kname.begin(), kname.end(), '_', ' ');
        std::istringstream iss(kname);
        std::vector<std::string> tokens{ std::istream_iterator<std::string>{iss},
                                         std::istream_iterator<std::string>{} };
        return tokens[0];
    }


    // based on cc_light_eqasm_compiler.h::get_prologue
    std::string codegen_kernel_prologue(ql::quantum_kernel &k)
    {
        std::stringstream ret;
        codegen.comment(ret, SS2S("# Kernel:  " << k.name));

        switch(k.type) {
            case kernel_type_t::IF_START:
            {
                auto op0 = k.br_condition.operands[0]->id;
                auto op1 = k.br_condition.operands[1]->id;
                auto opName = k.br_condition.operation_name;
                codegen.if_start(ret, op0, opName, op1);
                break;
            }

            case kernel_type_t::ELSE_START:
            {
                auto op0 = k.br_condition.operands[0]->id;
                auto op1 = k.br_condition.operands[1]->id;
                auto opName = k.br_condition.operation_name;
                codegen.else_start(ret, op0, opName, op1);
                break;
            }

            case kernel_type_t::FOR_START:
            {
                std::string label = kernelLabel(k);
                codegen.for_start(ret, label, k.iterations);
                break;
            }

            case kernel_type_t::DO_WHILE_START:
            {
                std::string label = kernelLabel(k);
                codegen.do_while_start(ret, label);
                break;
            }

            default:
                // nothing to do for other types
                break;
        }
        return ret.str();
    }


    // based on cc_light_eqasm_compiler.h::get_epilogue
    std::string codegen_kernel_epilogue(ql::quantum_kernel &k)
    {
        std::stringstream ret;

        switch(k.type) {
            case kernel_type_t::FOR_END:
            {
                std::string label = kernelLabel(k);
                codegen.for_end(ret, label);
                break;
            }

            case kernel_type_t::DO_WHILE_END:
            {
                auto op0 = k.br_condition.operands[0]->id;
                auto op1 = k.br_condition.operands[1]->id;
                auto opName = k.br_condition.operation_name;
                codegen.do_while_end(ret, op0, opName, op1);
                break;
            }

            default:
                // nothing to do for other types
                // FIXME: true for IF_END, ELSE_END?
                break;
        }
        return ret.str();
    }


    // based on cc_light_eqasm_compiler.h::bundles2qisa()
    std::string codegen_bundles(ql::ir::bundles_t &bundles, ql::quantum_platform &platform)
    {
        IOUT("Generating CCCODE for bundles");
        std::stringstream ret;
        size_t curr_cycle = 0;

        for(ql::ir::bundle_t &bundle : bundles)
        {
            auto delta = bundle.start_cycle - curr_cycle;
            bool classical_bundle = false;
            std::stringstream sspre, ssinst;    // FIXME: Is it necessary to split sspre and ssinst?

            // generate bundle header
            codegen.bundle_header(sspre, delta);

            // generate code for this bundle
            for(auto section = bundle.parallel_sections.begin(); section != bundle.parallel_sections.end(); ++section ) {
                // check whether section defines classical gate
                ql::gate *firstInstr = *section->begin();
                auto firstInstrType = firstInstr->type();
                if(firstInstrType == __classical_gate__) {
                    if(section->size() != 1) {
                        FATAL("Inconsistency detected: classical gate with parallel sections");
                    }
                    classical_bundle = true;
                    ssinst << codegen_classical_instruction(firstInstr);
                } else {
                    /* iterate over all instructions in section.
                     * NB: our strategy differs from cc_light_eqasm_compiler, we have no special treatment of first instruction
                     * and don't require all instructions to be identical
                     */
                    for(auto insIt = section->begin(); insIt != section->end(); ++insIt) {
                        ql::gate *instr = *insIt;
                        ql::gate_type_t itype = instr->type();
                        std::string iname = instr->name;

                        switch(itype) {
                            case __nop_gate__:       // a quantum "nop", see gate.h
                                codegen.nop_gate(ssinst);
                                break;

                            case __classical_gate__:
                                FATAL("Inconsistency detected: classical gate found after first section (which itself was non-classical)");
                                break;

                            case __custom_gate__:
                            {
                                auto nOperands = instr->operands.size();
                                auto nCoperands = instr->creg_operands.size();

                                // handle readout (NB: extracted from decompose_instructions)
                                if("readout" == platform.find_instruction_type(iname))   // FIXME: we only use the "readout" value and don't care about the rest because the terms "mw" and "flux" don't fully cover gate functionality. It would be nice if custom gates could mimic ql::gate_type_t
                                {
                                    DOUT("    readout instruction ");
                                    if(nCoperands != 1) {
                                        FATAL("Readout instruction requires exactly 1 classical operand, not " << nCoperands);
                                    }
                                    if(nOperands != 1) {
                                        FATAL("Readout instruction requires exactly 1 qubit operand, not " << nOperands);
                                    }

                                    auto &op0 = instr->operands[0];
                                    auto &cop0 = instr->creg_operands[0];
                                    codegen.readout(ssinst, cop0, op0);
                                } else { // handle all other instruction types
                                    if(1 == nOperands) {
                                        auto &op0 = instr->operands[0];
                                        codegen.custom_gate(ssinst, iname, op0, platform);
                                    } else if(2 == nOperands) {
                                        auto &op0 = instr->operands[0];
                                        auto &op1 = instr->operands[1];
                                        codegen.custom_gate(ssinst, iname, op0, op1, platform);
                                    } else {
                                        FATAL("Only 1 and 2 operand instructions are supported !");
                                    }
                                }
                                break;
                            }   // __custom_gate__

                            case __measure_gate__:
                                FATAL("__measure_gate__ not supported");    // FIXME: should we. Probably not, because there is no way to define CC-specifics
                                break;

                            case __display__:
                                FATAL("__display__ not supported");
                                break;

                            default:
                                FATAL("unsupported gate type" << itype);
                        }   // switch(itype)


#if 0   // FIXME: cc_light SMIS/SMIT handling
                        std::string rname;
                        if( 1 == nOperands )
                        {
                            rname = gMaskManager.getRegName(squbits);
                        }
                        else if( 2 == nOperands )
                        {
                            rname = gMaskManager.getRegName(dqubits);
                        }
                        else
                        {
                            throw ql::exception("Error : only 1 and 2 operand instructions are supported by cc light masks !",false);
                        }
                        ssinst << instr_name << " " << rname;
#endif
                    } // for(section...)


#if 0
                    if(std::next(section) != bundle.parallel_sections.end()) {
                        ssinst << " | ";
                    }
#endif
                }
            }


            // generate bundle trailer
            codegen.bundle_trailer(sspre, delta);
            {
                ret << sspre.str() << ssinst.str() << "\n";
            }

            curr_cycle += delta;
        }

#if 0   // FIXME: CC-light
        auto &lastBundle = bundles.back();
        int lbduration = lastBundle.duration_in_cycles;
        if(lbduration > 1)
            ret << "    qwait " << lbduration << "\n";
#endif

        IOUT("Generating CCCODE for bundles [Done]");
        return ret.str();
    }


    // based on: cc_light_eqasm_compiler.h::load_hw_settings
    void load_hw_settings(ql::quantum_platform& platform)
    {
        const struct {
            size_t  *var;
            std::string name;
        } hw_settings[] = {
            { &qubit_number,            "qubit_number"},
            { &cycle_time,              "cycle_time" },
#if 0   // FIXME: unused. Convert to cycle
            { &mw_mw_buffer,            "mw_mw_buffer" },
            { &mw_flux_buffer,          "mw_flux_buffer" },
            { &mw_readout_buffer,       "mw_readout_buffer" },
            { &flux_mw_buffer,          "flux_mw_buffer" },
            { &flux_flux_buffer,        "flux_flux_buffer" },
            { &flux_readout_buffer,     "flux_readout_buffer" },
            { &readout_mw_buffer,       "readout_mw_buffer" },
            { &readout_flux_buffer,     "readout_flux_buffer" },
            { &readout_readout_buffer,  "readout_readout_buffer" }
#endif
        };

        DOUT("Loading hardware settings ...");
        size_t i=0;
        try
        {
            for(i=0; i<ELEM_CNT(hw_settings); i++) {
                size_t val = platform.hardware_settings[hw_settings[i].name];
                *hw_settings[i].var = val;
            }
        }
        catch (json::exception e)
        {
            throw ql::exception(
                "[x] error : ql::eqasm_compiler::compile() : error while reading hardware settings : parameter '"
                + hw_settings[i].name
                + "'\n\t"
                + std::string(e.what()), false);
        }
    }

}; // class

} // arch
} // ql

#endif // QL_ARCH_CC_EQASM_BACKEND_CC_H

