/**
 * @file   codegen_cc.h
 * @date   201810xx
 * @author Wouter Vlothuizen (wouter.vlothuizen@tno.nl)
 * @brief  code generator backend for the Central Controller
 */

// FIXME: this should be the only backend specific code
// FIXME: check call structure of if_start here? Better in caller?
// FIXME: manage stringstream here


#ifndef QL_ARCH_CC_CODEGEN_CC_H
#define QL_ARCH_CC_CODEGEN_CC_H

namespace ql
{
namespace arch
{


class codegen_cc
{
public:

    codegen_cc()
    {
    }


    ~codegen_cc()
    {
    }


    /************************************************************************\
    | Generic
    \************************************************************************/

    void init(ql::quantum_platform& platform)
    {
        load_backend_settings(platform);
    }

    std::string getCode()
    {
        return cccode.str();
    }

    void program_header(std::string prog_name)
    {
        cccode << "# Program: '" << prog_name << "'" << std::endl;
        cccode << "# Note:    generated by OpenQL Central Controller backend" << std::endl;
        cccode << "#" << std::endl;
    }

    void program_trailer()
    {
        emit("", "stop");                                  // NB: cc_light loops whole program indefinitely
    }

    void bundle_header(int delta, std::string cmnt)
    {
        comment(cmnt);

        // init data structure of slots/groups/outputs/waveforms

#if 0   // FIXME: from CClight
            // delay start of bundle
            if(delta < 8)
                sspre << "    " << delta << "    ";
            else
                sspre << "    qwait " << delta-1 << "\n"
                      << "    1    ";
#endif
    }


    void bundle_trailer(int delta)
    {
        comment("");    // blank line to separate bundles

#if 0   // FIXME: from CClight: insert qwaits
            if(classical_bundle)
            {
                if(iname == "fmr")  // FIXME: this is cc_light instruction
                {
                    // based on cclight requirements (section 4.7 eqasm manual),
                    // two extra instructions need to be added between meas and fmr
                    if(delta > 2)
                    {
                        ret << "    qwait " << 1 << "\n";
                        ret << "    qwait " << delta-1 << "\n";
                    }
                    else
                    {
                        ret << "    qwait " << 1 << "\n";
                        ret << "    qwait " << 1 << "\n";
                    }
                }
                else
                {
                    if(delta > 1)
                        ret << "    qwait " << delta << "\n";
                }
                ret << "    " << cccode.str() << "\n";
            }
            else
#endif
    }

    void comment(std::string c)
    {
        if(verboseCode) emit(c.c_str());
    }

    /************************************************************************\
    | Quantum instructions
    \************************************************************************/

    void nop_gate()
    {
        comment("# NOP gate");
        // FIXME: implement
    }

    // single/two/N qubit gate
    // FIXME: remove parameter platform
    void custom_gate(std::string iname, std::vector<size_t> ops, ql::quantum_platform& platform)
    {
        std::string instr_name = platform.get_instruction_name(iname);  // FIXME: refers to cclight
// FIXME        comment(SS2S("# " << instr_name << " " << op0 << "," << op1).c_str());

        // iterate over signals defined in instruction
        json &instruction = platform.find_instruction(iname);
        json &signal = instruction["cc"]["signal"];
        for(size_t s=0; s<signal.size(); s++) {
            std::string instructionSignalType = signal[s]["type"];

            int operandIdx = signal[s]["operand_idx"];      // NB: cannot assign to size_t
            if(operandIdx >= (int)ops.size()) {
                FATAL("Illegal operand number " << operandIdx <<
                      " in instruction '" << iname <<
                      "' exceeds expected maximum of " <<
                      ops.size())
            }
            size_t qubit = ops[operandIdx];

            tSignalInfo si = findSignalInfoForQubit(instructionSignalType, qubit);
            json &instructionSignalValue = signal[s]["value"];
            comment(SS2S("# instrument=" << (*si.ccSetupSlot)["instrument"]["name"] <<
                         ", group=" << si.group <<
                         ", signal=" << instructionSignalValue));

            // FIXME: generate code
        }
    }

    /************************************************************************\
    | Readout
    \************************************************************************/

    void readout(size_t cop, size_t qop)
    {
        comment(SS2S("# READOUT(c" << cop << ",q" << qop << ")"));
    }

    /************************************************************************\
    | Classical operations on kernels
    \************************************************************************/

    void if_start(size_t op0, std::string opName, size_t op1)
    {
        comment(SS2S("# IF_START(R" << op0 << " " << opName << " R" << op1 << ")"));
        // FIXME: implement
    }

    void else_start(size_t op0, std::string opName, size_t op1)
    {
        comment(SS2S("# ELSE_START(R" << op0 << " " << opName << " R" << op1 << ")"));
        // FIXME: implement
    }

    void for_start(std::string label, int iterations)
    {
        comment(SS2S("# FOR_START(" << iterations << ")"));
        emit((label+":").c_str(), "move", SS2S(iterations << ",R63"), "# R63 is the 'for loop counter'");        // FIXME: fixed reg, no nested loops
    }

    void for_end(std::string label)
    {
        comment("# FOR_END");
        emit("", "loop", SS2S("R63,@" << label), "# R63 is the 'for loop counter'");        // FIXME: fixed reg, no nested loops
    }

    void do_while_start(std::string label)
    {
        comment("# DO_WHILE_START");
        // FIXME: implement: emit label
    }

    void do_while_end(size_t op0, std::string opName, size_t op1)
    {
        comment(SS2S("# DO_WHILE_END(R" << op0 << " " << opName << " R" << op1 << ")"));
        // FIXME: implement
    }

    /************************************************************************\
    | Classical arithmetic instructions
    \************************************************************************/

    void add();
    // etc


private:
    typedef struct {
        json *ccSetupSlot;
        int group;
    } tSignalInfo;


private:
    bool verboseCode = true;    // output extra comments in generated code

    std::stringstream cccode;

    // some JSON nodes we need access to. FIXME: use pointers for efficiency?
    json backendSettings;
    json instrumentDefinitions;
    json controlModes;
    json ccSetup;

    /************************************************************************\
    | Some helpers to ease nice assembly formatting
    \************************************************************************/

    void emit(const char *labelOrComment, const char *instr="")
    {
        cccode << std::left;    // FIXME
        if(!labelOrComment || strlen(labelOrComment)==0) {  // no label
            cccode << "        " << instr << std::endl;
        } else if(strlen(labelOrComment)<8) {               // label fits before instr
            cccode << std::setw(8) << labelOrComment << instr << std::endl;
        } else if(strlen(instr)==0) {                       // no instr
            cccode << labelOrComment << std::endl;
        } else {
            cccode << labelOrComment << std::endl << "        " << instr << std::endl;
        }
    }

    // @param   label       must include trailing ":"
    // @param   comment     must include leading "#"
    void emit(const char *label, const char *instr, std::string ops, const char *comment="")
    {
        cccode << std::left;    // FIXME
        cccode << std::setw(8) << label << std::setw(8) << instr << std::setw(16) << ops << comment << std::endl;
    }

    /************************************************************************\
    | Functions processing JSON
    \************************************************************************/

    void load_backend_settings(ql::quantum_platform& platform)
    {
        // parts of JSON syntax
        const char *instrumentTypes[] = {"cc", "switch", "awg", "measure"};

        // FIXME: we would like to have a top level setting, or one below "backends"
        // it is however not easy to create new top level stuff and read it from the backend
//        try
        {
            // remind some main JSON areas
            backendSettings = platform.hardware_settings["eqasm_backend_cc"];
            instrumentDefinitions = backendSettings["instrument_definitions"];
            controlModes = backendSettings["control_modes"];
            ccSetup = backendSettings["cc_setup"];


            // read instrument definitions
            for(size_t i=0; i<ELEM_CNT(instrumentTypes); i++)
            {
                json &ids = instrumentDefinitions[instrumentTypes[i]];
                // FIXME: the following requires json>v3.1.0:  for(auto& id : ids.items()) {
                for(size_t j=0; j<ids.size(); j++) {
                    std::string idName = ids[j]["name"];        // NB: uses type conversion to get node value
                    DOUT("found instrument definition:  type='" << instrumentTypes[i] << "', name='" << idName <<"'");
                }
            }

            // read control modes
            for(size_t i=0; i<controlModes.size(); i++)
            {
                json &name = controlModes[i]["name"];
                DOUT("found control mode '" << name <<"'");
            }


            // read instruments
            json &ccSetupType = ccSetup["type"];

            // CC specific
            json &ccSetupSlots = ccSetup["slots"];                      // FIXME: check against instrumentDefinitions
            for(size_t slot=0; slot<ccSetupSlots.size(); slot++) {
                json instrument = ccSetupSlots[slot]["instrument"];     // NB: don't use reference, because we want to put in std::vector
                std::string instrumentName = instrument["name"];
                std::string signalType = instrument["signal_type"];

                DOUT("found instrument: name='" << instrumentName << "signal type='" << signalType << "'");
            }
        }
#if 0
        catch (json::exception e)
        {
            throw ql::exception(
                "[x] error : ql::eqasm_compiler::compile() : error while reading backend settings : parameter '"
//                + hw_settings[i].name
                + "'\n\t"
                + std::string(e.what()), false);
        }
#endif
    }


    // find instrument/group/slot providing instructionSignalType for qubit
    tSignalInfo findSignalInfoForQubit(std::string instructionSignalType, size_t qubit)
    {
        tSignalInfo ret = {NULL, 0};
        bool signalTypeFound = false;
        bool qubitFound = false;

        // iterate over CC slots
        json &ccSetupSlots = ccSetup["slots"];
        for(size_t slotIdx=0; slotIdx<ccSetupSlots.size(); slotIdx++) {
            json &ccSetupSlot = ccSetupSlots[slotIdx];
            json &instrument = ccSetupSlot["instrument"];
            std::string instrumentSignalType = instrument["signal_type"];
            if(instrumentSignalType == instructionSignalType) {
                signalTypeFound = true;
                std::string instrumentName = instrument["name"];
                json &qubits = instrument["qubits"];
                // FIXME: verify group size
                // FIXME: verify signal dimensions

                // anyone connected to qubit?
                for(size_t group=0; group<qubits.size() && !qubitFound; group++) {
                    for(size_t idx=0; idx<qubits[group].size() && !qubitFound; idx++) {
                        if(qubits[group][idx] == qubit) {
                            qubitFound = true;

                            DOUT("qubit " << qubit <<
                                 " signal type '" << instructionSignalType <<
                                 "' driven by instrument '" << instrumentName <<
                                 "' group " << group <<
                                 " in CC slot " << ccSetupSlot["slot"]);

                            ret.ccSetupSlot = &ccSetupSlot;
                            ret.group = group;
                        }
                    }
                }
            }
        }
        if(!signalTypeFound) {
            FATAL("No instruments found providing signal type '" << instructionSignalType << "'");     // FIXME: clarify for user
        }
        if(!qubitFound) {
            FATAL("No instruments found driving qubit " << qubit << " for signal type '" << instructionSignalType << "'");     // FIXME: clarify for user
        }

        return ret;
    }
}; // class

} // arch
} // ql



#if 0   // FIXME: old code that may me useful
    // information extracted from JSON file:
    typedef std::string tSignalType;
    typedef std::vector<json> tInstrumentList;
    typedef std::map<tSignalType, tInstrumentList> tMapSignalTypeToInstrumentList;
    tMapSignalTypeToInstrumentList mapSignalTypeToInstrumentList;


    // insert into map, so we can easily retrieve which instruments provide "signal_type"
    tMapSignalTypeToInstrumentList::iterator it = mapSignalTypeToInstrumentList.find(signalType);
    if(it != mapSignalTypeToInstrumentList.end()) {    // key exists
        tInstrumentList &instrumentList = it->second;
        instrumentList.push_back(instrument);
    } else { // new key
        std::pair<tMapSignalTypeToInstrumentList::iterator,bool> rslt;
        tInstrumentList instrumentList;
        instrumentList.push_back(instrument);
        rslt = mapSignalTypeToInstrumentList.insert(std::make_pair(signalType, instrumentList));
    }


    // instruments providing these signal type
    // FIXME: just walk the CC slots?
    tMapSignalTypeToInstrumentList::iterator it = mapSignalTypeToInstrumentList.find(signalType);
    if(it != mapSignalTypeToInstrumentList.end()) {    // key exists
        tInstrumentList &instrumentList = it->second;
        for(size_t i=0; i<instrumentList.size(); i++) {

#endif

#endif  // ndef QL_ARCH_CC_CODEGEN_CC_H
