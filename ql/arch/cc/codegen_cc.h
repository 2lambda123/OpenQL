/**
 * @file   codegen_cc
 * @date   201810xx
 * @author Wouter Vlothuizen (wouter.vlothuizen@tno.nl)
 * @brief  code generator backend for the Central Controller
 */

// FIXME: this should be the only backend specific code
// FIXME: check call structure of if_start here? Better in caller?
// FIXME: manage stringstream here


#ifndef QL_ARCH_CC_CODEGEN_CC_H
#define QL_ARCH_CC_CODEGEN_CC_H

namespace ql
{
namespace arch
{

class codegen_cc
{
public:
    /*
     *  generic
     */

    void program_header(std::stringstream &s, std::string prog_name)
    {
        s << "# Program: '" << prog_name << "'" << std::endl;
        s << "# Note:    generated by OpenQL Central Controller backend" << std::endl;
        s << "#" << std::endl;
    }

    void program_trailer(std::stringstream &s)
    {
        emit(s, "", "stop");                                  // FIXME: cc_light loops whole program indefinitely
    }

    void bundle_header(std::stringstream &s, int delta)
    {
#if 0   // FIXME: from CClight
            // delay start of bundle
            if(delta < 8)
                sspre << "    " << delta << "    ";
            else
                sspre << "    qwait " << delta-1 << "\n"
                      << "    1    ";
#endif
    }


    void bundle_trailer(std::stringstream &s, int delta)
    {
#if 0   // FIXME: from CClight: insert qwaits
            if(classical_bundle)
            {
                if(iname == "fmr")  // FIXME: this is cc_light instruction
                {
                    // based on cclight requirements (section 4.7 eqasm manual),
                    // two extra instructions need to be added between meas and fmr
                    if(delta > 2)
                    {
                        ret << "    qwait " << 1 << "\n";
                        ret << "    qwait " << delta-1 << "\n";
                    }
                    else
                    {
                        ret << "    qwait " << 1 << "\n";
                        ret << "    qwait " << 1 << "\n";
                    }
                }
                else
                {
                    if(delta > 1)
                        ret << "    qwait " << delta << "\n";
                }
                ret << "    " << ssinst.str() << "\n";
            }
            else
#endif
    }

    void comment(std::stringstream &s)
    {
    }



    /*
     *  quantum instructions
     */

    void nop(std::stringstream &s)
    {
        if(verboseCode) emit(s, "# NOP gate");
        // FIXME: implement
    }


    /*
     *  readout
     */

    void readout(std::stringstream &s, size_t cop, size_t qop)
    {
        if(verboseCode) emit(s, SS2S("# READOUT(c" << cop << ",q" << qop << ")").c_str());
    }


    /*
     *  classical operations on kernels
     */

    void if_start(std::stringstream &s, size_t op0, std::string opName, size_t op1)
    {
        if(verboseCode) s << "# IF_START(R" << op0 << " " << opName << " R" << op1 << ")" << std::endl;
        // FIXME: implement
    }

    void else_start(std::stringstream &s, size_t op0, std::string opName, size_t op1)
    {
        if(verboseCode) s << "# ELSE_START(R" << op0 << " " << opName << " R" << op1 << ")" << std::endl;
        // FIXME: implement
    }

    void for_start(std::stringstream &s, std::string label, int iterations)
    {
        if(verboseCode) s << "# FOR_START(" << iterations << ")" << std::endl;
        emit(s, (label+":").c_str(), "move", SS2S(iterations << ",R63"), "# R63 is the 'for loop counter'");        // FIXME: fixed reg, no nested loops
    }

    void for_end(std::stringstream &s, std::string label)
    {
        if(verboseCode) emit(s, "# FOR_END");
        emit(s, "", "loop", SS2S("R63,@" << label), "# R63 is the 'for loop counter'");        // FIXME: fixed reg, no nested loops
    }

    void do_while_start(std::stringstream &s, std::string label)
    {
        if(verboseCode) s << "# DO_WHILE_START" << std::endl;
        // FIXME: implement: emit label
    }

    void do_while_end(std::stringstream &s, size_t op0, std::string opName, size_t op1)
    {
        if(verboseCode) s << "# DO_WHILE_END(R" << op0 << " " << opName << " R" << op1 << ")" << std::endl;
        // FIXME: implement
    }




    /*
     *  classical arithmetic instructions
     */

    void add();
    // etc





private:
    bool verboseCode = true;    // output extra comments in generated code

    // some helpers to ease nice assembly formatting
    void emit(std::stringstream &s, const char *labelOrComment, const char *instr="")
    {
        s << std::left;    // FIXME
        if(!labelOrComment || strlen(labelOrComment)==0) {  // no label
            s << "        " << instr << std::endl;
        } else if(strlen(labelOrComment)<8) {               // label fits before instr
            s << std::setw(8) << labelOrComment << instr << std::endl;
        } else if(strlen(instr)==0) {                       // no instr
            s << labelOrComment << std::endl;
        } else {
            s << labelOrComment << std::endl << "        " << instr << std::endl;
        }
    }

    // @param   label       must include trailing ":"
    // @param   comment     must include leading "#"
    void emit(std::stringstream &s, const char *label, const char *instr, std::string ops, const char *comment="")
    {
        s << std::left;    // FIXME
        s << std::setw(8) << label << std::setw(8) << instr << std::setw(16) << ops << comment << std::endl;
    }



}; // class

} // arch
} // ql


#endif  // ndef QL_ARCH_CC_CODEGEN_CC_H
