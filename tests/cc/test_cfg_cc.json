{
	// author: 	Wouter Vlothuizen
	// notes: 	based on '../test_cfg_none_s7.json'


	// Qubits in our setup:
	// see:
	// - "distrFWArch-v0.9.pdf"
	// - "Horizontal_instruction_definition.pdf" section 5.1: qubit numbering from left to right and top to bottom
	//
	// qubit	name		VSMbank	readoutRes
	// -------------------------------------
	//	1		D0			0			1
	//	2		D1			0			0
	//	3		D2			0			0
	//	7		D3			1			1
	//	8		D4			1			1
	//	9		D5			1			0
	//	13		D6			0			2
	//	14		D7			0			1
	//	15		D8			0			1
	//	0		A0			2			0
	//	4		A1			3			1
	//	5		A2			2			1
	//	6		A3			3			0
	//	10		A4			3			1
	//	11		A5			2			1
	//	12		A6			3			0
	//	16		A7			2			2


	"file_type": "OpenQL-config",
	"file_version": "1.1",
	"min_version_openql": "0.5.3",

	"eqasm_compiler" : "eqasm_backend_cc",

	"hardware_settings": {
		"qubit_number": 17,
		"cycle_time" : 20,
		// "mw_mw_buffer": 0,
		// "mw_flux_buffer": 0,
		// "mw_readout_buffer": 0,
		// "flux_mw_buffer": 0,
		// "flux_flux_buffer": 0,
		// "flux_readout_buffer": 0,
		// "readout_mw_buffer": 0,
		// "readout_flux_buffer": 0,
		// "readout_readout_buffer": 0,

		// FIXME: we put this key inside "hardware_settings" for now, but it should preferably be below "backend" or so
		"eqasm_backend_cc": {
			// Immutable properties of instruments.
			// FIXME: introduce 'controller_definitions'?
			"instrument_definitions": {
				"awg": [
					{	"name": "qutech-qwg",
						"channels": 4,
						"control_group_sizes": [4],
						"latency": 50		// FIXME: check
					},
					{	"name": "zi-hdawg",
						"channels": 8,
						"control_group_sizes": [1, 4, 8],
						"latency": 300		// FIXME: check. If latency depends on FW version, several definitions must be present
					}
				],
				"switch": [
					{	"name": "qutech-vsm",
						"channels": 32,
						"control_group_sizes": [1],
						"latency": 10		// FIXME: check
					}
				],
				"measure": [
					{	"name": "zi-uhfqc",
						"channels": 9,
						"control_group_sizes": [1],
						"latency": 150		// FIXME: check
					}
				]
			},

			// Modes to control instruments. These define which bits are used to
			// control groups of channels
			"control_modes": {
				"awg8-mw-vsm": {						// ZI_HDAWG8.py::cfg_codeword_protocol() == 'microwave'
					"control_bits": [
						[7,6,5,4,3,2,1,0],
						[15,14,13,12,11,10,9,8]
					],
					"trigger_bits": [31]
				},
				"awg8-mw-direct-iq": {				// just I&Q to generate microwave without VSM
					"control_bits": [
						[6,5,4,3,2,1,0],				// FIXME: no official mode yet
						[13,12,11,10,9,8,7],
						[20,19,18,17,16,15,14],
						[27,26,25,24,23,22,21]
					],
					"trigger_bits": [31]
				},
				"awg8-flux": {							// ZI_HDAWG8.py::cfg_codeword_protocol() == 'flux'
					"control_bits": [
						[2,1,0],
						[5,4,3],
						[8,7,6],
						[11,10,9],
						[14,13,12],
						[17,16,15],
						[20,19,18],
						[23,22,21]
					],
					"trigger_bits": [31]
				},
				"awg8-flux-vector": {				// single code word for 8 flux channels
					"control_bits": [
						[7,6,5,4,3,2,1,0]
					],
					"trigger_bits": [31]
				},
				"uhfqc-9ch": {
					"control_bits": [[25],[24],[23],[22],[21],[20],[19],[18],[17]],
					"trigger_bits": [16],
					"result_bits": [[9],[8],[7],[6],[5],[4],[3],[2],[1]],
					"data_valid_bits": [0]
				},
				"vsm-32ch":{
					"control_bits": [
						[0],[1],[2],[3],[4],[5],[6],[7],
						[8],[9],[10],[11],[12],[13],[14],[15],
						[16],[17],[18],[19],[20],[21],[22],[23],
						[24],[25],[26],[27],[28],[28],[30],[31]
					],
					"trigger_bits": []				// no trigger
				}
			},

			// Instruments used in this setup, their configuration and connectivity.
			"cc_setup": {
				"name": "cc-surface17",
				"type": "qutech-cc",
				"slots": [
					// microwave. FIXME: must match 'resources/qwgs'
					{	"slot": 0,
						"io_module": "cc-conn-dio-diff",
						"instrument": {
							"name": "awg8-mw-0",
							"type": "zi-hdawg",
							"control_mode": "awg8-mw-vsm",
							"signal_type": "mw",
							"qubits": [[0, 1, 2, 3], [4, 5, 6, 7]]
						}
					},
					// FIXME: add 1xmw
					// flux
					{	"slot": 5,
						"io_module": "cc-conn-dio-diff",
						"instrument": {
							"name": "awg8-flux-0",
							"type": "zi-hdawg",
							"control_mode": "awg8-flux",
							"signal_type": "flux",
							"qubits": [[0], [1], [2], [3], [4], [5], [6], [], [7]]
						}
					},
					// FIXME: add 2xflux
					// readout. FIXME: must match 'resources/meas_units'
					{	"slot": 7,
						"io_module": "cc-conn-dio",
						"instrument": {
							"name": "uhfqc-0",
							"type": "zi-uhfqc",
							"control_mode": "uhfqc-9ch",
							"signal_type": "measure",
							"qubits": [[0], [1], [2], [3], [4], [5], [6], [7], []]
						}
					},
					// FIXME: add 2xuhf
					// VSM
					{	"slot": 11,
						"io_module": "cc-conn-vsm",
						"instrument": {
							"name": "vsm-0",
							"type": "qutech-vsm",
							"control_mode": "vsm-32ch",
							"signal_type": "switch",
							"qubits": [[0], [1], [2], [3], [4], [5], [6], [7], [8]]
						}
					}
				]
			},

			// Signal library that gate definitions can refer to. Supports
			// macro expansion
			// NB: our library does not yet support JSON pointers like:
			// "signal": {"$ref": "#/hardware_settings/eqasm_backend_cc/signals/single-qubit"}
			"signals": {
				"single-qubit": [
					{	"type": "mw",
						"operand_idx": 0,
						"value": [
							"{gateName}-{instrumentName}:{instrumentGroup}-gi",
							"{gateName}-{instrumentName}:{instrumentGroup}-gq",
							"{gateName}-{instrumentName}:{instrumentGroup}-di",
							"{gateName}-{instrumentName}:{instrumentGroup}-dq"
						]
					},
					{	"type": "switch",
						"operand_idx": 0,
						"value": ["dummy"]	// NB: no actual signal is generated
					}
				],
				"two-qubit": [
					{	"type": "flux",
						"operand_idx": 0,		// FIXME: control, or target?
						"value": ["flux-0-{qubit}"]
					},
					{	"type": "flux",
						"operand_idx": 1,		// FIXME: control, or target?
						"value": ["flux-1-{qubit}"]
					}
				]

			}
		}
	},

	// see: "Horizontal_instruction_definition.pdf" section 5.1 for numbering scheme
	// FIXME: x and y coordinates are different from this documentation
	"topology": {
		// FIXME: apparently unused
		// "x_size": 5,
		// "y_size": 3,
		// "qubits": [
		// 	{ "id": 0,  "x": 1, "y": 2 },
		// 	{ "id": 1,  "x": 3, "y": 2 },
		// 	{ "id": 2,  "x": 0, "y": 1 },
		// 	{ "id": 3,  "x": 2, "y": 1 },
		// 	{ "id": 4,  "x": 4, "y": 1 },
		// 	{ "id": 5,  "x": 1, "y": 0 },
		// 	{ "id": 6,  "x": 3, "y": 0 }
		// ],

		// Directed edges between qubits (from "src" to "dst") define allowable
		// two qubit operations.
		// see:
		// - https://github.com/DiCarloLab-Delft/ElecPrj_CCLight/wiki/Qubit-number-and-directed-edge-number
		// - https://github.com/QE-Lab/OpenQL/blob/847ff7d373b5fe7ce23c0669cb194c79525aad2e/ql/arch/cc_light/cc_light_resource_manager.h#L352
		"edges": [
			{ "id": 0,  "src": 2, "dst": 0 },
			{ "id": 1,  "src": 0, "dst": 3 },
			{ "id": 2,  "src": 3, "dst": 1 },
			{ "id": 3,  "src": 1, "dst": 4 },
			{ "id": 4,  "src": 2, "dst": 5 },
			{ "id": 5,  "src": 5, "dst": 3 },
			{ "id": 6,  "src": 3, "dst": 6 },
			{ "id": 7,  "src": 6, "dst": 4 },
			{ "id": 8,  "src": 0, "dst": 2 },
			{ "id": 9,  "src": 3, "dst": 0 },
			{ "id": 10,  "src": 1, "dst": 3 },
			{ "id": 11,  "src": 4, "dst": 1 },
			{ "id": 12,  "src": 5, "dst": 2 },
			{ "id": 13,  "src": 3, "dst": 5 },
			{ "id": 14,  "src": 6, "dst": 3 },
			{ "id": 15,  "src": 4, "dst": 6 }
		]
	},


	"resources": {		// see: https://github.com/QE-Lab/OpenQL/blob/847ff7d373b5fe7ce23c0669cb194c79525aad2e/ql/arch/cc_light/cc_light_resource_manager.h#L724
		"qubits": {
			"count": 17
		},
		"qwgs" : {
			"count": 3,
			"connection_map": {
				"0" : [0, 1, 2, 3],
				"1" : [4, 5, 6]
			}
		},
		"meas_units" : {
			"count": 2,
			"connection_map":
			{
				"0" : [0, 2, 3, 5, 6],
				"1" : [1, 4]
			}
		},
		"edges": {
		 	"count": 16,
		 	// connection_map:
		 	// "0": [2, 10] means that edge 0 'connects' to edges 2 and 10, where edges
		 	// refer to the "id" in 'topology/edges'
		 	// The term 'connect' in this context means that an operation on edge 0
		 	// blocks operations on edges 2 and 10
		 	// see: https://github.com/QE-Lab/OpenQL/blob/847ff7d373b5fe7ce23c0669cb194c79525aad2e/ql/arch/cc_light/cc_light_resource_manager.h#L371
			"connection_map": {
				"0": [2, 10],
				"1": [3, 11],
				"2": [0, 8],
				"3": [1, 9],
				"4": [6, 14],
				"5": [7, 15],
				"6": [4, 12],
				"7": [5, 13],
				"8": [2, 10],
				"9": [3, 11],
				"10": [0, 8],
				"11": [1, 9],
				"12": [6, 14],
				"13": [7, 15],
				"14": [4, 12],
				"15": [5, 13]
			}
		}

		//"detuned_qubits"	FIXME: required?
	},

	// extracted from PyqQED_py3 'generate_CCL_cfg.py'
  	"gate_decomposition": {
      "x %0": ["rx180 %0"],
      "y %0": ["ry180 %0"],
      "roty90 %0": ["ry90 %0"],
      "cnot %0,%1": ["ry90 %1", "cz %0,%1", "ry90 %1"],

      // To support other forms of writing the same gates
      "x180 %0": ["rx180 %0"],
      "y180 %0": ["ry180 %0"],
      "y90 %0": ["ry90 %0"],
      "x90 %0": ["rx90 %0"],
      "my90 %0": ["rym90 %0"],
      "mx90 %0": ["rxm90 %0"],

      // Clifford decomposition per Epstein et al. Phys. Rev. A 89, 062321 (2014)
      "cl_0 %0": ["i %0"],
      "cl_1 %0": ["ry90 %0", "rx90 %0"],
      "cl_2 %0": ["rxm90 %0", "rym90 %0"],
      "cl_3 %0": ["rx180 %0"],
      "cl_4 %0": ["rym90 %0", "rxm90 %0"],
      "cl_5 %0": ["rx90 %0", "rym90 %0"],
      "cl_6 %0": ["ry180 %0"],
      "cl_7 %0": ["rym90 %0", "rx90 %0"],
      "cl_8 %0": ["rx90 %0", "ry90 %0"],
      "cl_9 %0": ["rx180 %0", "ry180 %0"],
      "cl_10 %0": ["ry90 %0", "rxm90 %0"],
      "cl_11 %0": ["rxm90 %0", "ry90 %0"],

      "cl_12 %0": ["ry90 %0", "rx180 %0"],
      "cl_13 %0": ["rxm90 %0"],
      "cl_14 %0": ["rx90 %0", "rym90 %0", "rxm90 %0"],
      "cl_15 %0": ["rym90 %0"],
      "cl_16 %0": ["rx90 %0"],
      "cl_17 %0": ["rx90 %0", "ry90 %0", "rx90 %0"],
      "cl_18 %0": ["rym90 %0", "rx180 %0"],
      "cl_19 %0": ["rx90 %0", "ry180 %0"],
      "cl_20 %0": ["rx90 %0", "rym90 %0", "rx90 %0"],
      "cl_21 %0": ["ry90 %0"],
      "cl_22 %0": ["rxm90 %0", "ry180 %0"],
      "cl_23 %0": ["rx90 %0", "ry90 %0", "rxm90 %0"]
  	},


	// FIXME: allow AWG8 setPrecompClear with wave
	// FIXME: key 'matrix' is required, but does not contain useful information
	"instructions": {
		// additions from 'CC-software-implementation.docx':
		"park_cz" : { // park signal with same length as cz gate
			"duration" : 40,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"cc": {
				"sig": {
					"flux": {
						"qubit": "q%0",	// FIXME: necessary, or implicit from parameters we get at runtime. Let's look at cz
						"wave": ["{gateName}-{instrumentName}"]
					}
//					"flux,<codeword>,%q" // %q assumes same codeword for all qubits
				}
			}
		},
		"park_measure" : { // park signal with same length as measurement
			"duration" : 300,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"cc": {
				"sig": {
//					"flux,<codeword>,%q" // %q assumes same codeword for all qubits
				}
			}
		},


		// based on PyqQED_py3 'generate_CCL_cfg.py':
		"prepz": {
			"duration": 200000,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "readout",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "prepz"
		},

		"measure": {
			"duration": 800,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "readout",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "measz",
			"cc": {
				"signal": [
					{	"type": "measure",
						"operand_idx": 0,
						"value": [
							"FIXME"	// FIXME: specify output and weight?
						]
					}
				]
			}
		},

		// based on PyqQED_py3 'mw_lutman.py' and 'generate_CCL_cfg.py':
		// FIXME: also add conditional single qubit gates?
		"i": {
			"duration": 20,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "mw",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "i",
			"cc": {
				"signal_ref": "single-qubit"
			}
		},
		"rx180": {
			"duration": 20,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "mw",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "x",
			"cc": {
				"signal_ref": "single-qubit"		// NB: reference, instead of defining "signal" here
			}
		},
		"ry180": {
			"duration": 20,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "mw",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "y",
			"cc": {
				"signal_ref": "single-qubit"
			}
		},
		"rx90": {
			"duration": 20,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "mw",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "x90",
			"cc": {
				"signal_ref": "single-qubit"
			}
		},
		"ry90": {
			"duration": 20,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "mw",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "y90",
			"cc": {
				"signal_ref": "single-qubit"
			}
		},
		"rxm90": {
			"duration": 20,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "mw",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "xm90",
			"cc": {
				"signal_ref": "single-qubit"
			}
		},
		"rym90": {
			"duration": 20,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": false,
			"type": "mw",
			"cc_light_instr_type": "single_qubit_gate",
			"cc_light_instr": "ym90",
			"cc": {
				"signal_ref": "single-qubit"
			}
		},



		// should handle:
		// https://github.com/QE-Lab/OpenQL/issues/166
		// https://github.com/QE-Lab/OpenQL/issues/180
		"cz": {
			"duration": 40,
			"latency": 0,
			"matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
			"disable_optimization": true,
			"type": "flux",
			"cc_light_instr_type": "two_qubit_gate",
			"cc_light_instr": "cz",
			"cc": {
				"signal_ref": "two-qubit"		// NB: reference, instead of defining "signal" here
			}
		}
	}	// end of "instructions"
}

